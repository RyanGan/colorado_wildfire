---
title: "Environmental Epidemiology and the Modifiable Areal Unit Problem"
author: "Ryan Gan"
date: '2018-03-22'
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

# Introduction

Environmental epidemiology rarely has individual-level estimates of exposure for study participants/outcomes observations. Exposure is assigned based on reported place of residence, which can vary on resolution based on data use agreements. 

For this particular set of analyses, I want to estimate the cardiopulmonary morbidity/mortality of PM~2.5~ assigned at the county-level, zipcode-level, and a 15 km^2^ grid level. 

I will use Colorado mortality and hospital discharge data I received from Kirk Bol at CDPHE. I have residential location of county, zipcode, and a 3x3 grid size. This document only focuses on the association of PM~2.5~ assigned at the county-level to comply with the spatial resolution Rish has.

```{r library}
# libraries
library(tidyverse) # data wrangle/plot
library(survival) # conditional logistic models
library(splines) # splines
library(lubridate) # works with dates
library(broom)
library(stringr)
library(sf)

# knitr options
knitr::opts_chunk$set(fig.width=8, fig.height=6, quite = T, message = F)
```

Setting up custom color theme.

```{r color_theme}
 ryan_theme <- theme(panel.background = element_rect(fill = "black", 
          colour = "black", size = 0.5, linetype = "solid"),
        panel.grid.major = element_line(size = 0.2, colour = "white"),
        panel.grid.minor = element_line(size = 0.1, color = "white", 
                                        linetype = "dotted"),
        plot.background = element_rect(fill = "#141e30", colour="#141e30",
                                       size = 0.5, linetype = "solid"),
        text = element_text(colour = "white"),
        axis.text = element_text(colour = "white"),
        strip.background = element_blank(),
        strip.text = element_text(colour="white"),
        legend.background = element_blank(),
        legend.key = element_blank())
```

## Maps

I want to know what the overlap between the Colorado grid and county interesects look like.

Reading in grid and county simple features.

```{r sf_objects}
# read county sf
county_sf <- st_read(dsn = "../../data/shapefiles/us_county/") %>% 
  filter(STATEFP == "08") %>% 
  mutate(fips = paste0(STATEFP, COUNTYFP))

# output wgs84 projection
wgs84 <- st_crs(county_sf)

# read grid
grid_sf <- st_read(dsn = "../../data/shapefiles/co_krig_grid/")
# assign wgs84
st_crs(grid_sf) <- wgs84

# plot
ggplot() +
  geom_sf(data = county_sf, fill = NA, color = "#2bc0e4") +
  geom_sf(data = grid_sf, fill = NA, color = "white", size = 0.1) +
  ryan_theme
```


## PM~2.5~ Exposure

Setting up funlag function to create lagged datastructures. 

```{r funlag}
# defining a lag function
funlag <- function(var, n=6){
  var <- enquo(var)
  indices <- seq_len(n)
  map( indices, ~quo(lag(!!var, !!.x)) ) %>% 
    set_names(sprintf("%s_lag%d", rlang::quo_text(var), indices))
}
```

### Grid Exposure

Import grid exposure values.

```{r grid_exp_impor}
# read grid pm
grid_pm <- read_csv("../../data/smoke/1015-grid_pm.csv", col_types = "cDdddd") %>% 
  mutate(pm_diff_grid = pm25_grid - sbg_pm_grid,
         month = as.factor(lubridate::month(date)), # extract month as factor
         year = as.factor(lubridate::year(date)), # extract year as factor
         season = as.factor(case_when(month %in% c(12, 1, 2) ~ "winter",
                                      month %in% c(3:5) ~ "spring",
                                      month %in% c(6:8) ~ "summer",
                                      month %in% c(9:11)~ "fall")),
         # creating binary smoke to hms to be equal to 1 
         # and difference between estimate and seasonal background to be >0
         # and to be within the month of April to Octoboer
         smk0_hms_g = ifelse(pm_diff_grid > 0 & month %in% c(4:10) & 
                               hms_grid == 1, 1, 0),
         smk5_hms_g = ifelse(pm_diff_grid > 5 & month %in% c(4:10) & 
                               hms_grid == 1, 1, 0),
         smk10_hms_g = ifelse(pm_diff_grid > 10 & month %in% c(4:10) & 
                                hms_grid ==  1, 1, 0),
         smk15_hms_g = ifelse(pm_diff_grid > 15 & month %in% c(4:10) & 
                                hms_grid ==  1, 1, 0),
         # transforming pm kriged estimates to a 10 unit increase in pm
         pm25_g_10u = pm25_grid/10) %>% 
  # sorting by fips and date to estimate lag for each county by date
  arrange(GRID_ID, date) %>% 
  # group by fips 
  group_by(GRID_ID) %>%
  # apply funlag to create lagged estimates
  mutate(., !!!funlag(pm25_g_10u,6), 
         !!!funlag(smk0_hms_g,6), !!!funlag(smk5_hms_g,6),
         !!!funlag(smk10_hms_g,6), !!!funlag(smk15_hms_g,6), 
         !!!funlag(temp_f_grid, 6))
```

### Zip Exposure

Spot for zip exposure when Jingyang finishes.

### County Exposure

Import county exposure values.

```{r import_county_pm}
county_pm <- read_csv(paste0("../../../meta_wildfire/data/smoke/",
  "1015-county_popwt_pm.csv")) %>% 
  # limiting to colorado counties only by reading 1st 2 digs of 5-dig fips code
  filter(str_sub(fips,start=1,end=2) %in% c("08")) %>% 
  rename(pm25_c = pm_krig, sbg_pm_c = bg_pm, pm_diff_c = pm_smk, hms_c = hms,
         temp_f_c = temp_f, aqi_c = aqi, aqi_cat_c = aqi_cat) %>% 
  mutate(pm_diff_c = pm25_c - sbg_pm_c,
         month = as.factor(lubridate::month(date)), # extract month as factor
         year = as.factor(lubridate::year(date)), # extract year as factor
         season = as.factor(case_when(month %in% c(12, 1, 2) ~ "winter",
                                      month %in% c(3:5) ~ "spring",
                                      month %in% c(6:8) ~ "summer",
                                      month %in% c(9:11)~ "fall")),
         # creating binary smoke to hms to be equal to 1 
         # and difference between estimate and seasonal background to be >0
         # and to be within the month of April to Octoboer
         smk0_hms_c = ifelse(pm_diff_c > 0 & month %in% c(4:10) & 
                               hms_c == 1, 1, 0),
         smk5_hms_c = ifelse(pm_diff_c > 5 & month %in% c(4:10) & 
                               hms_c == 1, 1, 0),
         smk10_hms_c = ifelse(pm_diff_c > 10 & month %in% c(4:10) & 
                                hms_c ==  1, 1, 0),
         smk15_hms_c = ifelse(pm_diff_c > 15 & month %in% c(4:10) & 
                                hms_c ==  1, 1, 0),
         # transforming pm kriged estimates to a 10 unit increase in pm
         pm25_c_10u = pm25_c/10) %>% 
  # sorting by fips and date to estimate lag for each county by date
  arrange(fips, date) %>% 
  # group by fips 
  group_by(fips) %>%
  # apply funlag to create lagged estimates
  mutate(., !!!funlag(pm25_c_10u,6), 
         !!!funlag(smk0_hms_c,6), !!!funlag(smk5_hms_c,6),
         !!!funlag(smk10_hms_c,6), !!!funlag(smk15_hms_c,6), 
         !!!funlag(temp_f_c, 6)) %>% 
  select(-c(year, month, season, smoke0, smoke5, smoke10, smoke15))
```

## Outcomes Data Frames

### Morbidity

### Mortality

Importing time-stratified case-crossover data frames and ICD-10 underlying cause of death data frames. 

```{r cvd_resp_deaths}
# load casecross  mortality list
load("../../data/health/co_mortality_cc_list.RData") 
# load icd10 outcome list
load("../../data/health/icd10_outcome.RData")
```

Joining with PM~2.5~ data and also limiting to front range counties. I'm also limiting to April and October.

```{r join_pm_data}
# extract a vector of outcome names from the icd10 outcomes list 
outcomes <- names(icd10_outcomes)

# fips front range
front_range_fips <- paste0("08", 
  c("001", "005", "013", "014", "031", "035", "041", "059", "069", "101", "123"))

# load grid id key
grid_key <- read_csv("../../data/shapefiles/wrfgrid_key.csv", 
                     col_types = cols(.default = "d", GRID_ID = "c", 
                                      WRFGRID_ID = "c")) %>% 
  select(GRID_ID, WRFGRID_ID)

# assign outcome names to each dataframe in list
co_mort_cc_list <- casecross_list %>% 
  # for some variables in the casecross dfs, I need to convert to character, then
  # desired format to make sure it's right
  map(~ mutate(., outcome = as.numeric(as.character(outcome)),
               date = as.Date(as.character(date_of_death)),
               month = as.factor(lubridate::month(date)),
               WRFGRID_ID = as.character(wrfgrid_id)) %>%
      # filter out 2016; I don't have pm data yet
      filter(date <= "2015-12-30") %>% 
      filter(month %in% 4:10) %>% 
      # filter to front range
      filter(fips %in% front_range_fips) %>% 
      # remove vars to prevent duplicates
      select(-c(wrfgrid_id, month)) %>% 
      left_join(grid_key, by = "WRFGRID_ID") %>% 
      left_join(grid_pm, by = c("GRID_ID", "date")) %>% 
      left_join(county_pm, by = c("fips", "date"))) %>% 
  # add outcome name to each dataframe
  map2(.x = ., .y = outcomes, ~mutate(.x, out_name = .y)) %>% 
  # removing asthma casecross list due to small sample size
  discard(names(.) == "asthma") 

# remove casecross_list to save space
rm(casecross_list)
```

## Same-Day Associations 

### Grid Level

Evaluating a same-day 10 ug/m^3^ increase in grid-level PM~2.5~ and risk for mortality for certain cardiopulmonary underlying causes of deaths. 

```{r same_day_pm}
# outcome name vector without asthma
outcome_name <- outcomes[-2]
# same-day association with pm and mortality during wildfire season
pm_grid_results <- co_mort_cc_list %>%
  map_dfr(. , function(df){
    mod <- clogit(outcome ~ pm25_g_10u + temp_f_grid + strata(id), data = df)
    est <- broom::tidy(mod) %>% filter(term == "pm25_g_10u") %>% 
      select(estimate, std.error, conf.low, conf.high) %>% 
      rename(se = std.error, lower_95 = conf.low, upper_95 = conf.high) %>% 
      mutate_at(vars(estimate, lower_95, upper_95), funs(round(exp(.),3))) %>% 
      mutate(level = "grid") 
    }) %>% # end map
  cbind(outcome_name, .)
```

a same-day 10 ug/m^3^ increase in county-level population-weighted PM~2.5~ and risk for mortality for certain cardiopulmonary underlying causes of deaths. 

```{r same_day_conty_pm}
# same-day association with pm and mortality during wildfire season
pm_co_results <- co_mort_cc_list %>%
  map_dfr(. , function(df){
    mod <- clogit(outcome ~ pm25_c_10u + temp_f_c + strata(id), data = df)
    est <- broom::tidy(mod) %>% filter(term == "pm25_c_10u") %>% 
      select(estimate, std.error, conf.low, conf.high) %>% 
      rename(se = std.error, lower_95 = conf.low, upper_95 = conf.high) %>% 
      mutate_at(vars(estimate, lower_95, upper_95), funs(round(exp(.),3))) %>% 
      mutate(level = "county")
    }) %>% # end map
  cbind(outcome_name, .)
```

Binding estimates for grid- and county-level same-day estimates together and plotting.

```{r same_day_plot}
# bind dataframes
plot_df <- bind_rows(pm_grid_results, pm_co_results)

# plot
plot <- ggplot(plot_df, aes(x=level, y = estimate, colour = level)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.3) +
  scale_color_manual(values = c("#9cecfb", "#ff00cc")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  facet_wrap(~outcome_name, scales = "free_y") +
  ylab("Odds Ratio: 10 ug/m^3") +
  xlab("Outcome") +
  ggtitle(paste0("Association between PM2.5 and Mortality")) +
  ryan_theme +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 90, hjust=0.95, vjust = 0.75))
# print plot
plot
```

I find it interesting that the county-level estimates are essentially the same as grid-level. I guess that could be explained in part by population-weighting? Maybe I should add some area weighting estimates or some other cruder form of aggregating grids in a county to see if I get similar results.

## Distributed Lag

Set up distributed lag function.

```{r distributed_lag_fun}
distribute_that_lag <- function(lag_mod, strata, exposure_basis) {
  # output pm basis estimates
  parms <- broom::tidy(lag_mod) %>% 
    filter(stringr::str_detect(term, strata)) %>% 
    select(estimate) %>% 
    as_vector()
  # output estimate names for cov matrix
  names <- stringr::str_subset(names(lag_mod$coefficients), strata)
  # estimate associations
  est <- exposure_basis %*% parms
  # estimate standard error for each interval
  # time variable
  time <- ((rep(1:length(est))-1))
  # covariance matrix for knots 
  cov_mat <- as.matrix(vcov(lag_mod))[names, names]
  # estimate variance of spline
  var <- exposure_basis %*% cov_mat %*% t(exposure_basis)
  # estimate lag ----
  # estimate standard error for each lag day for smoke
  l_se <- sqrt(diag(var))
  # calculate lower and upper bound for smoke
  l_est_l95 <- est + (l_se*qnorm(1-0.975))
  l_est_u95 <- est + (l_se*qnorm(0.975))
  l_type <- "lag"
  # lag dataframe
  l_df <- data.frame(strata, l_type, time, 
                     exp(est), exp(l_est_l95), exp(l_est_u95), 
                     row.names = NULL) 
  # assign column names
  colnames(l_df) <- c("strata", "type", "time", 
                      "odds_ratio", "lower_95", "upper_95")
  # cumulative estimates
  c_est <- sapply(seq_along(est), function(x){
    sum(est[1:x])
  })
  # stderr cumulative effect smk
  c_se <- sapply(seq_along(c_est), function(y){
    sqrt(sum(var[1:y,1:y]))
  })
  # estimate 95% CI
  c_l95 <- c_est+(c_se*qnorm(1-0.975))
  c_u95 <- c_est+(c_se*qnorm(0.975))
  # type
  c_type <- "cumulative"
  # return dataframe
  c_df <- data.frame(strata, c_type, time, exp(c_est), 
                     exp(c_l95), exp(c_u95), row.names = NULL) 
  # assign column names
  colnames(c_df) <- c("strata", "type", "time", 
                      "odds_ratio", "lower_95", "upper_95")
  # bind lagged and cumulative 
  lag_est <- rbind(l_df, c_df) %>% 
    mutate(strata = as.character(strata),
           type = as.character(type))
  # return lagged estimate
   return(lag_est)
 } # end lag estimate function
```

Itterating through list of case-crossover dataframes and running distributed lag models with 3 degrees of freedom for lag funciton.

```{r pm_mortality results}
# distributed lag function
mort_dl_pm_results  <- lapply(co_mort_cc_list, function(x){
  # output dataframe from list
  data <- x %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(pm25_g_10u_lag6))
  # output outcome name
  out_name <- as.character(unique(data$out_name))
  # print(out_name) # track which outcome dataframe it's on
  # create lagged matrix
  pm_mat <- as.matrix(select(data, contains("pm25_g_10u")))
  temp_mat <- as.matrix(select(data, contains("temp_f_grid")))
  # define lagged basis spline
  exp_b <- ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + strata(id), data = data)
  
  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm", 
                                 exposure_basis = exp_b) %>% 
    mutate(outcome = out_name) %>% select(outcome, strata:upper_95)
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind)
```

Plotting cumulative effect of PM~2.5~ over a week of exposure.

```{r cardpulm_cumulative}
# subsetting to cumulative resutls
cumulative_results <- mort_dl_pm_results %>% filter(type == "cumulative")
# plot results
plot <- ggplot(cumulative_results, aes(x=time, y=odds_ratio)) +
  geom_line(colour = "blue", size = 1) +
  geom_ribbon(aes(ymin = lower_95, ymax = upper_95), 
              fill = "blue", alpha = 0.3) + 
  scale_x_continuous(breaks = c(seq(0,7, by=1))) +
  geom_hline(yintercept = 1, linetype = 2, colour = "red") +
  # adding facet wrap to estimate for each outcome
  facet_wrap(~outcome, scales = "free_y") +
  ylab(expression("Odds Ratio: 10 ug/m^3 increase PM2.5")) +
  xlab("Lagged Days") +
  ggtitle("Grid-Level Cumulative Effect of PM2.5 on Cardiorespiratory Mortality") +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank()) +
  theme_minimal()
# plot cumulative effect
print(plot)
```

Plot shows a cumulative effect of multiple days of increased exposure in PM~2.5~ for respiratory 0 to 3 days after exposure, getting as high as a 10% relative increase in risk. For CVD, there is an association, but the effect takes longer, which is around 3 to 4 days of increased exposure. The effect gets as high as 10% relative increase in risk. Other possible outcomes of interest. Cardiac arrest has unreasonably high confidence intervals. I may get rid of this underlying cause of death. I saw these same effects in the county-level estimates with similar confidence intervals. 

Consider limiting to only CVD deaths and Respiratory deaths to make the story more straight-forward. I think you can then make plots that are readable and present the cumulative effects for grid, zip, county. Also consider finding degrees of freedom for best spline fit. I've said it before that I think 3 df is good enough for a lot of reasons, but if publishing, it may not hurt to just find best df based on model AIC.

This could really be a general air pollution paper I think. But since this was originally designed to look at the impact wildfire smoke has on populations in Colorado, I'm going to go ahead an run an interaction mode at the assignment of PM~2.5~ at the grid level.

### Estimating Effect of PM~2.5~ on Smoke Days and Non-Smoke Days

```{r int_dl}
# start time
start_time <- Sys.time()
# distributed lag function
mort_dl_pm_int_results  <- lapply(co_mort_cc_list, function(x){
  # output dataframe from list
  data <- x %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(pm25_g_10u_lag6))
  # output outcome name
  out_name <- as.character(unique(data$out_name))
  # print(out_name) # track which outcome dataframe it's on
  # create lagged matrix
  pm_mat <- as.matrix(select(data, contains("pm25_g_10u")))
  temp_mat <- as.matrix(select(data, contains("temp_f_grid")))
  # define lagged basis spline
  exp_b <- ns(0:(ncol(pm_mat)-1), df = 4, intercept = T)
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # create vector of smoke var to estimate over
  smoke_var <- c("smk0_hms_g", "smk5_hms_g", "smk10_hms_g")

  smoke_results <- smoke_var %>% 
    map(function(s){ 
      smk_mat <- as.matrix(select(data, contains(s)))
      # lagged pm x basis
      pm_basis <- pm_mat %*% exp_b
      smk_basis <- smk_mat %*% exp_b
      # smoke basis for interaction
      pm_smk_b <- pm_basis * smk_basis 
      pm_nosmk_b <- pm_basis * ifelse(smk_basis == 1, 0, 1)
      # run lagged model
      lag_mod <- clogit(outcome ~ pm_smk_b + pm_nosmk_b + smk_basis + 
                          temp_basis + strata(id), data = data)
      # define strata terms
      strata_terms <- c("pm_smk_b", "pm_nosmk_b", "smk_basis")
      # estimate cumulative and lagged effect for each basis
      
      lagged_estimates <- strata_terms %>% 
        map_dfr(~distribute_that_lag(lag_mod = lag_mod, strata = ., 
                                     exposure_basis = exp_b)) %>% 
        mutate(outcome = out_name, smoke = s) %>% 
        select(outcome, smoke, strata:upper_95)
                
      return(lagged_estimates)      
    }) %>%  # end smoke map
      # bind rows
      map_dfr(.,rbind)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind)
# stop time
stop_time <- Sys.time() - start_time
stop_time
```

Plot of cumulative effect.

```{r int_cumulative_effect}
cumulative_nosmk <- mort_dl_pm_int_results %>% 
  filter(type == "cumulative" & smoke == "smk5_hms_g" & 
          strata == "pm_nosmk_b" & outcome != "card_arrest")

# plot results
plot_nosmk <- ggplot(cumulative_nosmk, aes(x=time, y=odds_ratio)) +
  geom_line(colour = "blue", size = 1) +
  geom_ribbon(aes(ymin = lower_95, ymax = upper_95), 
              fill = "blue", alpha = 0.3) + 
  scale_x_continuous(breaks = c(seq(0,7, by=1))) +
  geom_hline(yintercept = 1, linetype = 2, colour = "red") +
  # adding facet wrap to estimate for each outcome
  facet_wrap(~outcome, scales = "free_y") +
  ylab(expression("Odds Ratio")) +
  xlab("Lagged Days") +
  ggtitle("No Smoke") +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank()) +
  theme_minimal()

# print plot
print(plot_nosmk)
```


```{r}
cumulative_smk <- mort_dl_pm_int_results %>% 
  filter(type == "cumulative" & smoke == "smk5_hms_g" & 
           strata == "pm_smk_b" &  outcome != "card_arrest")

# plot results
plot_smk <- ggplot(cumulative_smk, aes(x=time, y=odds_ratio)) +
  geom_line(colour = "blue", size = 1) +
  geom_ribbon(aes(ymin = lower_95, ymax = upper_95), 
              fill = "blue", alpha = 0.3) + 
  scale_x_continuous(breaks = c(seq(0,7, by=1))) +
  geom_hline(yintercept = 1, linetype = 2, colour = "red") +
  # adding facet wrap to estimate for each outcome
  facet_wrap(~outcome, scales = "free_y") +
  ylab(expression("Odds Ratio")) +
  xlab("Lagged Days") +
  ggtitle("Smoke") +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank()) +
  theme_minimal()

# print plot
print(plot_smk)
```

## Morbidity

Just realized i need to make a whole new time stratified case-crossover list for Colorado as I didn't keep the WRFGRID_ID.

```{r morbidity_cc}
load("../../../meta_wildfire/data/health/2015-morbidity_casecross_list.RData")
load("../../../meta_wildfire/data/health/icd9_outcome_vectors.RData")

# 
# f
co_morb_cc_list <-   
  # desired format to make sure it's right
  map(~ select(., identifier:state) %>% 
        mutate(outcome = as.numeric(as.character(outcome)),
               date = as.Date(as.character(date_of_death)),
               month = as.factor(lubridate::month(date)),
               WRFGRID_ID = as.character(wrfgrid_id)) %>%
      # filter out 2016; I don't have pm data yet
      filter(date <= "2015-12-30") %>% 
      filter(month %in% 4:10) %>% 
      # filter to front range, this will get only colorado
      filter(fips %in% front_range_fips) %>% 
      # remove vars to prevent duplicates
      select(-c(wrfgrid_id, month)) %>% 
      left_join(grid_key, by = "WRFGRID_ID") %>% 
      left_join(grid_pm, by = c("GRID_ID", "date")) %>% 
      left_join(county_pm, by = c("fips", "date"))) %>% 
  # add outcome name to each dataframe
  map2(.x = ., .y = outcomes, ~mutate(.x, out_name = .y)) %>% 
  # removing asthma casecross list due to small sample size
  discard(names(.) == "asthma") 
```



