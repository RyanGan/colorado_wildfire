---
title: "Colorado wildfire smoke and cardiopulmonary morbidity"
output:
  html_document:
    df_print: paged
editor_options:
  chunk_output_type: inline
---

## Introduction

This Mark Down file contains code and results evaluating the effect of wildfire smoke on cardiopulmonary morbidity and mortality along the Colorado front range communities from 2010 to 2015. The hypothesis for this study is that we will see an increase in the risk of cardiopulmonary morbidity and mortality associated with an increase in PM2.5 due to wildfire smoke.

```{r setup, include = F}
# library
library(tidyverse)
library(survival)
library(sf)

# knitr options
knitr::opts_chunk$set(fig.width=8, fig.height=6, 
                      warning=FALSE, message=FALSE, echo = FALSE)
```

## Study Area Map
Study bounding box.
```{r study_bbox}
# clip by bbox function ------
bbox_clip <- function(sf, bbox) {
  # find the CRS of the sf object
  crs <- sf::st_crs(sf)$proj4string
  # create matrix
  x <- c(bbox[1], bbox[1], bbox[3], bbox[3], bbox[1])
  y <- c(bbox[2], bbox[4], bbox[4], bbox[2], bbox[2])
  coords <- matrix(cbind(x, y), ncol=2)
  # create polygon and assign same coord crs as sf object
  coords_poly <- sp::Polygon(coords)
  bbox_poly <- sp:: SpatialPolygons(list(sp::Polygons(list(coords_poly),
    ID = "bbox")), proj4string = sp::CRS(crs))
  # convert to sf feature
  bbox_sf <- st_as_sf(bbox_poly)
  # clip sf object
  clipped_sf <- sf[bbox_sf,]
  return(clipped_sf)
}

# clipping bounding box
study_bbox <- st_bbox(c(xmin=-105.3, xmax=-104.5, ymax=41, ymin = 38))
```


Reading in county shapefiles.

```{r colorado_counties}
# county subset
county_sub_name <- c("Larimer", "Weld", "Boulder", "Broomfield", "Adams", 
                "Denver", "Jefferson", "Arapahoe", "Douglas", "El Paso",
                "Pueblo")

# read in county shapefile and subset to only colorado fips
co_county_sf <- st_read("../../../meta_wildfire/data/shapefile/us_county", 
                        layer = "us_county") %>%
  # limit to colorado
  filter(STATEFP == "08") %>% 
  # create fips variable
  mutate(fips = paste0(STATEFP, COUNTYFP))

# save wgs84 crs
wgs <- st_crs(co_county_sf)

# county clip
county_clip <- bbox_clip(co_county_sf, study_bbox)

# extract county names
county_text <- county_clip %>% 
  st_transform(wgs) %>% 
  st_centroid() %>% 
  st_coordinates() %>% 
  cbind(., as.character(county_clip$NAME)) %>%
  as_data_frame() %>% 
  rename(lon = X, lat = Y, county = V1) %>% 
  mutate(lon = as.numeric(lon), lat = as.numeric(lat))
```

Reading in Front Range Grid points that will define who is included in the study area.

```{r read_grid}
# read in front range grid csv
frontrange_grid <- read_csv('../../data/smoke/front_range_grid.csv') 

# read in grid simple features and limit to the front range grid
study_grid <- read_sf('../../data/shapefiles/co_krig_grid/', crs = wgs) %>% 
  filter(GRID_ID %in% frontrange_grid$GRID_ID)
```


Interstate shapefile limited to I-25 and I-70.
```{r interstate_sf}
# read in colorado roads shapefile
interstate <- st_read(paste0("../../data/shapefiles/tl_2015_08_prisecroads"), 
                      layer = "tl_2015_08_prisecroads") %>% 
  # filter to I25 lines
  filter(RTTYP == "I") %>% 
  st_transform(crs = wgs)

# interstate clip
i_clip <- bbox_clip(interstate, study_bbox)
```

Reading in city boundary simple features.
```{r city_sf}
# read in city polygons 2010
city <- st_read("../../data/shapefiles/Colorado_City_Point_Locations/", 
                layer = "Colorado_City_Point_Locations") %>% 
  st_transform(crs = wgs)

# limit cities 
city_points <- city %>% 
  filter(NAME %in% c("FORT COLLINS", "PUEBLO", "GREELEY", "BOULDER", "DENVER",
                     "COLORADO SPRINGS")) %>% 
  mutate(city = stringr::str_to_title(NAME))
```

Reading 2015 population estimate geotiff for Colorado. I made this file for the ALA project from the SEDAC 2015 global estimate.

```{r population_raster}
# read colorado 2015 population raster
co_pop_2015 <- raster::raster("../../data/shapefiles/2015-ColoradoPopDensity.tif")
# extract bbox of clipped county subset
fr_extent <- raster::extent(st_bbox(county_clip)[c(1,3,2,4)])
# raster
fr_pop_2015 <- raster::crop(co_pop_2015, fr_extent)

# i'm going to create a shapefile/simple features; easier to plot
front_range_pop_sf <- st_as_sf(raster::rasterToPolygons(fr_pop_2015)) %>% 
  rename(popden = X2015.ColoradoPopDensity) %>% 
  # filtering to cells > 100 
  filter(popden > 100)

# cut once more to county shapefile so that populations outside the counties are not present
pop_clip <- front_range_pop_sf[county_clip,]
```

### Map of Study Area

Study map that will contain an inset map to highlight the area of interest.

Inset map.
```{r state_map}
# extent of county clip
study_bbox <- st_bbox(county_clip)[c(1,3,2,4)]
study_extent <- as_data_frame(matrix(study_bbox,
                       nrow = 1, ncol = 4, byrow = T)) %>% 
  rename(xmin = V1, xmax = V2, ymin = V3, ymax = V4)
# create county inset map
inset_map <- ggplot(co_county_sf) +
  geom_sf(fill = "transparent", color = "black", size = 0.1) +
  geom_rect(data = study_extent, 
    aes(xmin = xmin, xmax = xmax, ymin = ymin, ymax = ymax), 
    fill = "red", color = "transparent", alpha = 0.5) +
  ggtitle("Colorado: Study Area") +
  theme(plot.title = element_text(size = 12),
        panel.background = element_blank(),
        panel.grid.major = element_line(colour = 'transparent'),
        panel.grid.minor = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        plot.background = element_rect(fill = "transparent", 
                                       color = "transparent"))
inset_map
```

Study map.
```{r study_map}
# plot map
study_map <-ggplot(pop_clip) +
  # start with plot of simple features of populations
  geom_sf(aes(fill=popden), color = NA) +
  # define aesthetics of poipulation
    scale_fill_gradient(name = expression("Population per km"^2), 
      low = "#26d0ce", high = "#1a2980") +
  # plot lines of counties
  geom_sf(data = county_clip, color = "black", 
          fill = "transparent", size = 0.5) +
  # plot i-25 and i-70
  geom_sf(data = i_clip, aes(color = "Interstate"), show.legend = "line") +
  # plot study grid
  geom_sf(data = study_grid, aes(color = "Study Grid"), fill = "transparent", 
          size = 0.1, show.legend = "line") +
  # custom colors for interstate and study grid
  scale_color_manual(values = c("Interstate" = "#0f9b0f", 
                                "Study Grid" = "red"), 
    labels = c("Interstate", "Study Grid"),
    name = "Boundary") + 
  # major city points and names
  geom_point(data = city_points, aes(x = LONG, y = LAT), color = "#3f2b96") +
  geom_text(data = city_points, aes(x = LONG, y = LAT, label = city), 
             color = "#3f2b96", size = 4, hjust = 1, vjust = -0.6) +
  # theme
  theme(panel.background = element_blank(),
        panel.grid.major = element_line(colour = 'transparent'),
        panel.grid.minor = element_blank(),
        axis.text = element_blank(),
        axis.ticks = element_blank(),
        axis.title = element_blank(),
        legend.key = element_rect(fill = NA, colour = NA, size = 0.25))

study_map
```

Final map with inset. Using the grid package.I may add the AQS monitors to this map.

```{r map_w_inset}
# save map
#tiff(filename = "../analysis/figures/study_map.tiff", w=850, h=550)
grid::grid.newpage()
vpmain <- grid::viewport(width = 1, height = 1, x = 0.5, y = 0.5)
vpinset <- grid::viewport(width = 0.25, height = 0.25, x = 0.7, y = 0.85)
print(study_map, vp = vpmain)
print(inset_map, vp = vpinset)
```

## Smoke PM2.5

Kate has estimated PM2.5 at 15x15 km grid level using kriged surface site monitors for the entire US from 2010 to 2015. I have limited the gridded PM2.5 to Colorado Front Range study grid. I have also estimated population-weighted PM2.5 for all Colorado counties (although I don't think I'll use it for this project). There were concerns about the accuracy of the krig PM in areas outside of the front range communities since most PM stations are on the Front Range. 

I am also going to set up this lag function here to create lagged days that will be used in the analysis.

```{r lag_fun}
# defining a lag function that I will use later in the distributed lag model
funlag <- function(var, n=5){
  var <- enquo(var)
  indices <- seq_len(n)
  map( indices, ~quo(lag(!!var, !!.x)) ) %>% 
    set_names(sprintf("%s_lag%d", rlang::quo_text(var), indices))
}
```

I'd like to find the most likely grid for each county and plot each grid for each county instead of the population-weighted county estimates. I'm going to find the county name for which has the largest proportion of intersection of the grid.

```{r grid_county_ids}
# identifying the county that most of the grid lies in
grid_county_id <- st_intersection(study_grid, county_clip) %>% 
  select(GRID_ID, NAME, fips) 

# proportion each grid in county
grid_prop <- as.numeric(st_area(grid_county_id)/st_area(study_grid))

# find the county id that contains the highest proportion for each grid
grid_county_final <- grid_county_id %>% 
  mutate(prop_int = grid_prop,
         GRID_ID = as.character(GRID_ID)) %>% 
  group_by(GRID_ID) %>% 
  filter(prop_int == max(prop_int))

# remove geometry
st_geometry(grid_county_final) <- NULL
```

Consider removing this following section.

```{r import_county_pm}
# front range fips
fr_fips <- c("08001", "08005", "08013", "08031", "08035", "08041",
             "08059", "08069", "08123")

# read pm data 
co_pm <- read_csv("../../data/smoke/1015-county_popwt_pm.csv") %>% 
  # limiting to colorado counties only by reading 1st 2 digs of 5-dig fips code
  filter(fips %in% fr_fips) %>% 
  # renaming variable pm_smk to pm_diff; more accurate description of var
  rename(pm_diff = pm_smk) %>% 
  # us
  mutate(county_name = case_when(fips == '08001' ~ 'Adams',
                                 fips == '08005' ~ 'Arapahoe',
                                 fips == '08013' ~ 'Boulder',
                                 fips == '08031' ~ 'Denver',
                                 fips == '08035' ~ 'Douglas',
                                 fips == '08041' ~ 'El Paso',
                                 fips == '08059' ~ 'Jefferson',
                                 fips == '08069' ~ 'Larimer',
                                 fips == '08123' ~ 'Weld'),
         day = as.factor(weekdays(date)), # create day of week based on var
         weekend = ifelse(day %in% c("Saturday", "Sunday"), 1, 0),
         month = as.factor(lubridate::month(date)), # extract month as factor
         year = as.factor(lubridate::year(date)), # extract year as factor
         season = as.factor(case_when(month %in% c(12, 1, 2) ~ "winter",
                                      month %in% c(3:5) ~ "spring",
                                      month %in% c(6:8) ~ "summer",
                                      month %in% c(9:11)~ "fall")),
         # creating binary smoke to require 50% of county with smoke overhead
         # and difference between estimate and seasonal background to be >0
         # and to be within the month of April to Octoboer
         smoke0_hms = ifelse(pm_diff > 0 & month %in% c(5:10) & hms > 0.5,1,0),
         smoke5_hms = ifelse(pm_diff > 5 & month %in% c(5:10) & hms > 0.1,1,0),
         smoke10_hms = ifelse(pm_diff > 10 & month %in% c(5:10) & hms > 0.1,1,0),
         smoke15_hms = ifelse(pm_diff > 15 & month %in% c(5:10) & hms > 0.1,1,0),
         # transforming pm kriged estimates to a 10 unit increase in pm
         pm = pm_krig/10, 
         # continuous pm smoke accounting for hms
         cpm_smk = ifelse(hms > 0.1 & month %in% c(5:10), pm_diff, 0),
         cpm_smk = ifelse(cpm_smk < 0, 0, cpm_smk),
         aqi_warning = ifelse(aqi_cat %in% 
            c('Unhealthy', 'Unhealthy for Sensitive Groups'), 1, 0)) %>%  
  # sorting by fips and date to estimate lag for each county by date
  arrange(fips, date) %>% 
  # group by fips 
  group_by(fips) %>%
  # apply funlag to create lagged estimates
  mutate(., !!!funlag(pm,3), !!!funlag(smoke0_hms,3), !!!funlag(smoke5_hms,3),
         !!!funlag(smoke10_hms,3), !!!funlag(smoke15_hms,3), 
         !!!funlag(temp_f, 3)) %>% 
  select(-state, -month) # removing state and month to bind with casecross
```

### Front Range Grid Estimates of Smoke PM2.5 2010 to 2015

To try and estimate PM2.5 from smoke vs. other sources, I've taken the estimated kriged value of PM2.5 and subtracted off the seasonal background of PM2.5 and only consider this difference to be from smoke if there is smoke in the atmospheric column using the HMS grids. For county population-weighted values, I use a rather loose definition of at least 10% of the county with smoke overhead. The grid-level estimate of smoke is probably more reliable. I'll show some quick diagnostic plots below.

Here is a plot of the population-weighted smoke PM2.5 for each Front Range county.       

```{r grid_pm_ts_plot}
pm_plot <- ggplot(data=co_pm, aes(x=date, y=cpm_smk)) +
  geom_point(size = 0.5, color = "#6441a5") +
  facet_wrap(~county_name) +
  xlab('Date') +
  ylab('County Smoke PM2.5 ug/m^3') +
  theme_minimal()
# plot
print(pm_plot)
```

This definition of smoke seems reasonable. I do have some concerns with the Kriged model in that there isn't enough stations to capture spatial variations. For example, the 2012 Waldo Canyon Fire likely affected south Front Range counties like El Paso a little after the High Park Fire likely affected northern front range counties like Larmier. Does the county population-weighted time series reflect this? All the smoke peaks across look uniform across Front Range counties. This could be explained by the kriging process if certain sites are really driving the smoothed surfaces. 

Maps of the study area and specific fires may help understand the exposure series. I will work on these after some input.

```{r grid_pm}
# code chunk that reads in grid pm2.5 and prepares some lagged variables
# for joining with health outcomes data.

# read new grid/wrfgrid key
grid_key <- read_csv('../../data/shapefiles/wrfgrid_key.csv', 
                     col_types = list(GRID_ID = col_character(),
                                      WRFGRID_ID = col_character())) %>% 
  select(-COLX, -ROWY)

# read grid pm
grid_pm <- read_csv('../../data/smoke/1015-grid_pm.csv', 
                    col_types = list(GRID_ID = col_character())) %>% 
  # create some variables         
  mutate(pm_diff_g = pm25_grid - sbg_pm_grid,
         month = as.factor(lubridate::month(date)), # extract month as factor
         gsmk5_hms = ifelse(pm_diff_g > 5 & month %in% c(4:10) & hms_grid == 1,
                            1,0),
         gsmk10_hms = ifelse(pm_diff_g > 10 & month %in% c(4:10) & hms_grid == 1,
                             1,0),
         gsmk15_hms = ifelse(pm_diff_g > 15 & month %in% c(4:10) & hms_grid == 1,
                             1,0),
         # continuous pm smoke accounting for hms
         gpm_smk = ifelse(hms_grid == 1 & month %in% c(5:10), pm_diff_g, 0),
         gpm_smk = ifelse(gpm_smk < 0, 0, gpm_smk),
         # transforming pm smke estimates to a 10 unit increase in pm
         gpm_smk10unit = gpm_smk/10) %>% 
         # sorting by GRID_ID and date to estimate lag for each county by date
         arrange(GRID_ID, date) %>% 
         # group by GRID_ID 
         group_by(GRID_ID) %>%
         # apply funlag to create lagged estimates
         mutate(., !!!funlag(gpm_smk10unit,3), !!!funlag(gsmk5_hms,3),
               !!!funlag(gsmk10_hms,3), !!!funlag(gsmk15_hms,3),
               !!!funlag(temp_f_grid, 3)) %>% 
         select(-month) %>% 
         # filter to grids in study area
         filter(GRID_ID %in% frontrange_grid$GRID_ID) %>% 
         # join county id
         left_join(select(grid_county_final, GRID_ID, NAME, fips), 
                   by = 'GRID_ID')
```

Grid smoke values in each front range county. 

```{r pm_ts_plot}
# front range fips
fr_fips <- c("08001", "08005", "08013", "08031", "08035", "08041",
             "08059", "08069", "08123")

pm_plot <- ggplot(data=filter(grid_pm, fips %in% fr_fips), 
                  aes(x=date, y=gpm_smk, group = GRID_ID)) +
  geom_point(size = 0.5, color = "#6441a5") +
  facet_wrap(~NAME) +
  xlab('Date') +
  ylab(expression(paste("Smoke PM"[2.5]," in ", mu,"g/m"^3))) +
  theme_minimal()
# plot
print(pm_plot)
```

Reading ozone estimates.

```{r grid_o3}
ozone <- read_csv('../../data/smoke/1015-frontrange_kriged_o3.csv') %>% 
  mutate(GRID_ID = as.character(GRID_ID)) %>% 
  # sorting by GRID_ID and date to estimate lag for each county by date
  arrange(GRID_ID, date) %>% 
  # group by GRID_ID 
  group_by(GRID_ID) %>%
  # apply funlag to create lagged estimates
  mutate(., !!!funlag(o3_8hr_max_ppb,3))
```

## Hospitalizations and Mortality

I've created time-stratified case-crossover data frames for both mortality and hospitalization data provided by CDPHE with reference periods within a month of the observation. The justification for a 'month' period is appropriate for mortality I think, as I think it's reasonable counter factual window in when a person could have died. A longer period like we've previously used like the entire wildfire season may not be as appropriate for mortality for a person who is already at risk of death.

### Hospitalizations

```{r load_morbidity}
# load casecross list
load("../../data/health/1015-co_morbidity_casecross_list.RData")
# load icd9
load("../../data/health/icd9_outcome_vectors.RData")
```

Cleaning hospitalization data and joining with both grid-level and count-level PM2.5 data. I consider the following inpatient hospitalization events with admitting source via the emergency room or urgent care (as a way to get at acute events): all respiratory, asthma, chronic obstructive pulmonary disease (COPD), acute bronchitis, pneumonia, all cardiovascular events, arrhythmia, cerebrovascular, heart failure, ischemic heart disease, and myocardial infraction (which is a subcategory of IHD).

Some notes for the Colorado hospitalization data is that unlike Washington and Oregon, I have no way of identifying multiple events per person so I am not able to limit to first event and I am assuming each event is independent of others. Also, unlike Washington and Oregon, I've decided to go with monthly referent periods rather than the whole wildfire season. Possible suggestion would be to run sensitivity analyses to see if this has an impact.

```{r hosp_pm}
# extract names
outcome <- c('All Respiratory', 'Asthma', 'COPD', 'Acute Bronchitis',
              'Pneumonia', 'All CVD', 'Arrhythmia', 'Cerebrovascular',
              'Heart Failure', 'Ischemic Heart Disease', 
              'Myocardial Infarction')

# reduce case-crossover list to only summer months and join GRID ID
co_hosp_list <- co_morbidity_cc_list %>% 
  # desired format to make sure it's right
  map(~ mutate(., outcome = as.numeric(as.character(outcome)),
               date = as.Date(as.character(date)),
               month = as.factor(lubridate::month(date))) %>% 
      # filter out 2016; I don't have pm data yet
      filter(date <= "2015-12-30") %>% 
      filter(month %in% 5:10) %>% 
      filter(fips %in% fr_fips) %>% 
      select(-state, -month) %>% 
      # join with grid key
      left_join(grid_key, by = 'WRFGRID_ID') %>% 
      left_join(co_pm, by = c("fips", "date")) %>% 
      # left join grid pm
      left_join(grid_pm, by = c("GRID_ID", "date")) %>% 
      left_join(ozone, by = c("GRID_ID", "date")) %>% 
      # filter to front range grid ids
      filter(GRID_ID %in% frontrange_grid$GRID_ID)) %>% 
  # add outcome name to each dataframe
  map2(.x = ., .y = outcome, ~mutate(.x, out_name = .y))
```

### Colorado Hospitalization Respiratory and Cardiovascular Time Series

Creating and plotting the time series of respiratory and cardiovascular events for the state of Colorado. 

```{r hosp_ts}
# create time series of hospitalizations
ts_hosp <- co_morbidity_cc_list[c(1,6)] %>% 
  # using map 2 to add outcome names to each dataframe
  map2(., names(co_morbidity_cc_list[c(1,6)]), function(df, name){
    counts <- df %>% 
      filter(outcome == 1) %>% 
      group_by(date) %>% 
      summarise(n = n()) %>% 
      mutate(outcome = name,
             date = as.Date(date))
    }) %>% 
  # bind dataframes
  map_dfr(.,rbind)
```

```{r hosp_ts_plot}
ts_hosp_plot <- ggplot(data=ts_hosp, aes(x=date, y=n)) +
  geom_point() +
  facet_wrap(~outcome) +
  theme_minimal()

ts_hosp_plot
```

The cardiovascular hospitalization is pretty uniform, with some noticeable dips at the end of the year of 2013 and when ICD9 switches to ICD10 at the end of the time series. I'd say this is probably a systemic thing that has to do with coding or how hospitals recorded events rather than an actual big drop in the rate of CVD hospitalizations. Although may Kirk or some others at CDPHE may know.

### Counts of Hospitalization Events

Number of inpatient hospitalization events that occurred in Colorado Front Range Communities between 2010 and 2015 in the May to October Months. Also note that October of 2015 is when ICD9 was switched to ICD10, so I do not have that last month.

```{r hosp_counts}
strata <- c('All', 'Sex', 'Age')
# estimate hospitalizations
hosp_counts <- co_hosp_list %>% 
  map_dfr(.,function(df){
    map_dfr(strata, function(x){
    if(x == 'All'){
      counts <- df %>% 
        filter(outcome == 1) %>% 
        group_by(out_name) %>% 
        summarise(n_events = n()) %>% 
        mutate(strata = x) %>% 
        select(out_name, strata, n_events)
    } else if(x == 'Sex'){
      counts <- df %>% 
        filter(outcome == 1) %>% 
        group_by(out_name, sex) %>% 
        summarise(n_events = n()) %>% 
        rename(strata = sex) %>% 
        select(out_name, strata, n_events)
    } else {
      counts <- df %>% 
        filter(outcome == 1) %>% 
        group_by(out_name, age_cat) %>% 
        summarise(n_events = n()) %>% 
        rename(strata = age_cat) %>% 
        select(out_name, strata, n_events)
    }
    }) # end strata map
  }) %>% # end outcome list map
  spread(strata, n_events) %>% 
  select(out_name, All, F, M, age_under_15, age_15_to_65, age_over_65) %>% 
  mutate_at(vars(F:age_over_65), funs(round((./All)*100,1)))

# print death counts
knitr::kable(hosp_counts, caption = 'Number of Inpatient Events')
```

### Assessment of Assigned PM2.5

Quick assessment of how well my smoke PM2.5 definition at the grid level correlates at the county level for front range counties. I've used the cardiovascular hospitalizations (as they are most common) to plot the assigned county smoke PM2.5 vs grid smoke PM2.5 It looks like the values are similar in some respect, and sometimes not. I would assume the grid level is more accurate since my definition requires the grid be completely impacted by smoke based on the HMS plume.

```{r assigned_pm}
ggplot(data = filter(co_hosp_list[[6]], !is.na(gpm_smk)), 
                     aes(x=cpm_smk, y =gpm_smk)) +
  geom_point() +
  ylab('Grid Smoke PM2.5') +
  xlab('County Smoke PM2.5') +
  ggtitle('Comparison of County vs Grid Smoke PM2.5') +
  theme_minimal()
```

Check how many events have a county PM assigned but not a grid PM assigned.

```{r missing_grid}
missing <- co_hosp_list[[6]] %>% 
  filter(outcome == 1) %>% 
  mutate(county_miss = ifelse(is.na(pm_krig), 1, 0),
         grid_miss = ifelse(is.na(pm25_grid), 1, 0)) %>% 
  group_by(county_miss, grid_miss) %>% 
  summarize(n = n()) %>% 
  mutate(prop = round(n/(69064+8716), 2))

knitr::kable(missing, caption = 'CVD Hospitalization Proportion Missing Grid PM2.5')
```

Roughly 10% of subjects with a CVD hospitalization are missing grid PM2.5 which I'm guessing is because Kirk was not able to Geocode for what ever reason.

### Same Day Association between Smoke PM2.5 and Inpatient Hospitalizations

First things first is to look at the same day association between an increase in smoke PM2.5 and the risk for an inpatient hospitalization.

```{r sameday_model}
# extract names
outcome <- c('All Respiratory', 'Asthma', 'COPD', 'Acute Bronchitis',
              'Pneumonia', 'All CVD', 'Arrhythmia', 'Cerebrovascular',
              'Heart Failure', 'Ischemic Heart Disease', 
              'Myocardial Infarction')
# outcome order
out_order <- c('All Respiratory', 'Asthma', 'COPD', 'Acute Bronchitis',
              'Pneumonia', 'All CVD', 'Arrhythmia', 'Cerebrovascular',
              'Heart Failure', 'Ischemic Heart Disease', 
              'Myocardial Infarction')

# same day results
same_day <- co_hosp_list %>% 
  map_dfr(., function(df){
    out_name <- unique(df$out_name)
    result <- broom::tidy(clogit(outcome ~ gpm_smk10unit + o3_8hr_max_ppb +
                                 temp_f_grid + strata(id),
                                 data = df)) %>% 
      filter(term == 'gpm_smk10unit') %>% 
      select(term, estimate, conf.low, conf.high) %>% 
      mutate_at(vars(estimate:conf.high), exp)
  }) %>%
  bind_cols(data.frame(outcome), .) %>% 
  mutate(outcome = forcats::fct_relevel(outcome, out_order),
         group = as.factor(if_else(outcome %in% out_order[1:5],
         "Respiratory", "Cardiovascular")))
```

Same-day plot.

```{r sameday_plot}
# plot
plot <- ggplot(data=same_day, aes(x=outcome, y = estimate, colour = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=conf.low, ymax=conf.high), width = 0.3) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: Smoke PM"[2.5], " > 10 ", mu, "g/m"^3))) +
  xlab("Outcome") +
  theme_bw() +
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=0.95, vjust = 0.75))

print(plot)
```

There is no association for most outcomes. Notable observation would be the inverse association between increasing smoke and a lower likelihood of a respiratory hospitalization. 

Here is a table for the point estimated and 95%CIs from the plot above. The gpm_smk10unit stands for grid PM2.5 smoke estimate, 10 unit increase.

```{r sameday_hosp_table}
knitr::kable(select(same_day, outcome, estimate:conf.high), 
  caption = 'Same Day Association with Smoke and Cardiopulmonary Hospitalizations')
```


### Cumulative effect for a 10 ug/m^3 of smoke exposure over 4 days

```{r lag_function}
distribute_that_lag <- function(lag_mod, strata) {
  # output pm basis estimates
  parms <- broom::tidy(lag_mod) %>% 
    filter(stringr::str_detect(term, strata)) %>% 
    select(estimate) %>% 
    as_vector()
  # output estimate names for cov matrix
  names <- stringr::str_subset(names(lag_mod$coefficients), strata)
  # define lagged basis spline if it doesn't exist
  exp_b <- splines::ns(0:3, df = 3, intercept = T)
  # estimate associations
  est <- exp_b %*% parms
  # estimate standard error for each interval
  # time variable
  time <- ((rep(1:length(est))-1))
  # covariance matrix for knots 
  cov_mat <- as.matrix(vcov(lag_mod))[names, names]
  # estimate variance of spline
  var <- exp_b %*% cov_mat %*% t(exp_b)
  # estimate lag ----
  # estimate standard error for each lag day for smoke
  l_se <- sqrt(diag(var))
  # calculate lower and upper bound for smoke
  l_est_l95 <- est + (l_se*qnorm(1-0.975))
  l_est_u95 <- est + (l_se*qnorm(0.975))
  l_type <- "lag"
  # lag dataframe
  l_df <- data.frame(strata, l_type, time, 
                     exp(est), exp(l_est_l95), exp(l_est_u95), 
                     row.names = NULL) 
  # assign column names
  colnames(l_df) <- c("strata", "type", "time", 
                      "odds_ratio", "lower_95", "upper_95")
  # cumulative estimates
  c_est <- sapply(seq_along(est), function(x){
    sum(est[1:x])
  })
  # stderr cumulative effect smk
  c_se <- sapply(seq_along(c_est), function(y){
    sqrt(sum(var[1:y,1:y]))
  })
  # estimate 95% CI
  c_l95 <- c_est+(c_se*qnorm(1-0.975))
  c_u95 <- c_est+(c_se*qnorm(0.975))
  # type
  c_type <- "cumulative"
  # return dataframe
  c_df <- data.frame(strata, c_type, time, exp(c_est), 
                     exp(c_l95), exp(c_u95), row.names = NULL) 
  # assign column names
  colnames(c_df) <- c("strata", "type", "time", 
                      "odds_ratio", "lower_95", "upper_95")
  # bind lagged and cumulative 
  lag_est <- rbind(l_df, c_df) %>% 
    mutate(strata = as.character(strata),
           type = as.character(type))
  # return lagged estimate
  return(lag_est)
} # end lag estimate function
```

Contstrained distributed lag results.

```{r hosp_dl_results}
# estimating lagged effects
out_rep <- rep(outcome, each = 8)

dl_results  <- lapply(co_hosp_list, function(x){
  # output dataframe from list
  data <- x %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  
  # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + o3_basis + temp_basis + strata(id), 
                    data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(out_rep), .) 
```

```{r cumulative_cardiopulmonary_results}
# get the cumulative effect over 4 days
cumulative_results <- filter(dl_results, type == 'cumulative' & time == 3) %>% 
    select(-strata, -time) %>% 
    mutate(outcome = forcats::fct_relevel(outcome, out_order),
         group = as.factor(if_else(outcome %in% out_order[1:5],
         "Respiratory", "Cardiovascular")))
```

Cumulative effect of 0 to 3 days of smoke exposure for a 10 ug/m^3. 

```{r cumulative_resp_plot}
# plot
plot <- ggplot(data = cumulative_results, 
               aes(x=outcome, y = odds_ratio, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.3) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Outcome") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=0.95, vjust = 0.75,
                                   size = 10))

print(plot)
```

There may be an association with hospitalizations for asthma and certain cardiovascular events (cerebrovascular, heart failure, IHD) for every 10 ug/m^3 of smoke PM2.5 over the course of 4 days of smoke exposure.

Table of cumulative effects results for a 10 ug/m^3 increase in smoke PM2.5

```{r cumulative_hosp_table}
knitr::kable(select(cumulative_results, outcome, type:upper_95), 
  caption = 'Cumulative effect of smoke on Cardiopulmonary Hospitalizations')
```

### Constrained distributed lag effects for a 10 ug/m^3 increase in smoke

Creating a plot showing the individual lagged day effects on cardiopulmonary hospitalizations. This is a constrained distributed lag model, meaning all lagged days are accounted for in the model.

```{r constrained_lag_results}
constrained_lag_results <- dl_results %>% 
  mutate(outcome = forcats::fct_relevel(out_rep, out_order),
         group = as.factor(if_else(outcome %in% out_order[1:5],
         "Respiratory", "Cardiovascular"))) %>% 
  filter(type == 'lag')

# constrained distributed lag
dl_hosp_plot <- ggplot(data=constrained_lag_results, 
    aes(x=time, y=odds_ratio, group = group, color = group, fill = group)) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin = lower_95, ymax = upper_95), color = 'transparent',
              alpha = 0.5) +
  facet_wrap(~outcome, scales = 'free_y', ncol = 4) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  scale_fill_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Lagged Days") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        legend.direction = 'horizontal',
        legend.position = 'bottom',
        panel.grid.minor = element_blank(),
        strip.background = element_blank())

print(dl_hosp_plot)
```

For all respiratory and asthma, there appears to be a inverse association (or trending towards an inverse association) on the same day of exposure, with a steady increase in the risk on day 3. I think the acute bronchitis and pneumonia signals are noisy and the day 3 association is not likely real (suggesting that maybe my model decision is not great). It could be that I need to further reduce the lagged days evaluated to maybe 0 to 2 since the smoke events are pretty brief.

```{r dl_hosp_table}
knitr::kable(select(constrained_lag_results, outcome, time:upper_95),
  caption = 'Distributed Lag Daily Associations with Smoke and Cardiopulmonary Hospitalizations')
```

### Unconstrained Lag Model for Hospitalizations

Running an unconstrained lag model where I model the cooresponding lagged day of smoke, adjusting for the same lag day of temperature and ozone. This model is for comparison with our 2012 Washington paper and to see how sensitive our distributed lag models are.

```{r unconstrained_lag_hosp}
# repeat outcomes 4 times
out_rep <- rep(outcome, each = 4)
# day to repeat
day <- rep(0:3, times = 11)

# lag day vector
lag_days <- c('', '_lag1', '_lag2', '_lag3')

# map across lagged days
hosp_uc_lag_results <- map_dfr(co_hosp_list, function(df){
  data <- df
    results <- map_dfr(lag_days, function(x){
      # define function
      f <- as.formula(paste('outcome~',
        paste(paste0(c('gpm_smk10unit', 'o3_8hr_max_ppb', 'temp_f_grid'), 
                     x), collapse = '+'),
        '+strata(id)'))
      r <- broom::tidy(clogit(f, data = data)) %>% 
      filter(term == paste0('gpm_smk10unit',x)) %>% 
      select(term, estimate, conf.low, conf.high) %>% 
      mutate_at(vars(estimate:conf.high), exp)
    })
  }) %>% 
  cbind(out_rep, day, .) %>% 
  mutate(outcome = forcats::fct_relevel(out_rep, out_order),
         group = as.factor(if_else(outcome %in% out_order[1:5],
         "Respiratory", "Cardiovascular"))) 
```

*Plot of unconstrained lag results for hospitalizations.*

```{r uc_lag_plot}
uc_plot <- ggplot(data=hosp_uc_lag_results, aes(x=day, y=estimate, 
                                                group = group, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=conf.low, ymax=conf.high), width = 0.3) +
  facet_wrap(~outcome, scales = 'free_y', ncol = 4) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Lagged Days") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        legend.direction = 'horizontal',
        legend.position = 'bottom',
        panel.grid.minor = element_blank(),
        strip.background = element_blank())

print(uc_plot)
```

In the context of the distributed lag models, this may help confirm some of the associations. I think the respiratory and asthma trends are supported by these plots. Same with ischemic heart disease. 

Unconstrained lag associations table.

```{r unconstrained_hosp_table}
knitr::kable(select(hosp_uc_lag_results, outcome, day, estimate:conf.high),
  caption = 'Unconstrained Lag Daily Associations with Smoke and Cardiopulmonary Hospitalizations')
```

### Sex-Specific Stratification

Using the distributed lag model for each sex strata. Also modifying code to pull out n cases analyzed.

```{r sex_dl_results}
# estimating lagged effects
out_rep <- rep(outcome, each = 16)

sex_strata <- c('F', 'M')

sex_results  <- map_dfr(co_hosp_list, function(df){
  results <- map_dfr(sex_strata, function(x){
   data <- df %>% 
     filter(sex == x) %>% 
     mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))
   
    # create lagged matrix
    pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
    # temp matrix
    temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                                 temp_f_grid_lag2, temp_f_grid_lag3))
    
    # ozone matrix
    o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                               o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
    
    # define lagged basis spline
    exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
    # pm basis
    pm_basis <- pm_mat %*% exp_b
    # temp basis
    temp_basis <- temp_mat %*% exp_b
    # ozone basis
    o3_basis <- o3_mat %*% exp_b
    # run lagged model
    lag_mod <- clogit(outcome ~ pm_basis + o3_basis + temp_basis + strata(id), 
                      data = data)
  
    # estimate lag estimate
    lag_est <- distribute_that_lag(lag_mod, strata = "pm") %>% 
      mutate(sex = x)
    return(lag_est)
  }) 
}) %>% 
  # bind in outcome names
  bind_cols(data.frame(out_rep), .) 
```

Sex-specific plots of the cumulative effect.

```{r sex_strata_plot}
# subset to cumulative results
cumulative_sex_strata <- sex_results %>% 
  filter(type == 'cumulative' & time == 3) %>% 
  mutate(sex_long = if_else(sex == 'F', 'Female', 'Male'),
         outcome = forcats::fct_relevel(out_rep, out_order),
         group = as.factor(if_else(outcome %in% out_order[1:5],
         "Respiratory", "Cardiovascular"))) 

# plot
sex_plot <- ggplot(data=cumulative_sex_strata, aes(x=sex_long, y=odds_ratio, 
                                        group = group, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.3) +
  facet_wrap(~outcome, scales = 'free_y', ncol = 4) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Sex") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        legend.direction = 'horizontal',
        legend.position = 'bottom',
        panel.grid.minor = element_blank(),
        strip.background = element_blank())

print(sex_plot)
```

Sex-specific estimates table.

```{r sex_strata_table}
knitr::kable(select(cumulative_sex_strata, outcome, sex_long, odds_ratio:upper_95),
             caption = 'Sex-specific cumulative effect of smoke on hosptializations.')
```

### Age-Specific Stratification

Age category stratified results. 


```{r age_dl_results}
# estimating lagged effects
out_rep <- rep(outcome, each = 24)

age_strata <- c('age_under_15', 'age_15_to_65', 'age_over_65')

age_results  <- map_dfr(co_hosp_list, function(df){
  results <- map_dfr(age_strata, function(x){
   data <- df %>% 
     filter(age_cat == x) %>% 
     mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))
   
    # create lagged matrix
    pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
    # temp matrix
    temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                                 temp_f_grid_lag2, temp_f_grid_lag3))
    
    # ozone matrix
    o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                               o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
    
    # define lagged basis spline
    exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
    # pm basis
    pm_basis <- pm_mat %*% exp_b
    # temp basis
    temp_basis <- temp_mat %*% exp_b
    # ozone basis
    o3_basis <- o3_mat %*% exp_b
    # run lagged model
    lag_mod <- tryCatch(clogit(outcome ~ pm_basis + o3_basis + temp_basis + strata(id), 
                      data = data))
  
    # estimate lag estimate
    lag_est <- distribute_that_lag(lag_mod, strata = "pm") %>% 
      mutate(age_cat = x)
    return(lag_est)
  })
}) %>% 
  # bind in outcome names
  bind_cols(data.frame(out_rep), .) 
```

Age-specific plots of the cumulative effect.

```{r age_strata_plot}
# subset to cumulative results
cumulative_age_strata <- age_results %>% 
  filter(type == 'cumulative' & time == 3) %>% 
  mutate(age_long = forcats::fct_relevel(
      case_when(age_cat == 'age_under_15' ~ 'Age < 15',
                age_cat == 'age_15_to_65' ~ 'Age 15 to 64',
                age_cat == 'age_over_65' ~ 'Age > 64'),
      c('Age < 15', 'Age 15 to 64', 'Age > 64')),
         outcome = forcats::fct_relevel(out_rep, out_order),
         group = as.factor(if_else(outcome %in% out_order[1:5],
         "Respiratory", "Cardiovascular"))) %>% 
  filter(upper_95 < 3.5)

# plot
age_plot <- ggplot(data=cumulative_age_strata, aes(x=age_long, y=odds_ratio, 
                                        group = group, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.3) +
  facet_wrap(~outcome, scales = 'free_y', ncol = 4) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Sex") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        legend.direction = 'horizontal',
        legend.position = 'bottom',
        panel.grid.minor = element_blank(),
        strip.background = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=0.95, vjust = 0.75))

print(age_plot)
```

Age-specific estimates table.

```{r age_strata_table}
knitr::kable(select(cumulative_age_strata, outcome, age_long, odds_ratio:upper_95),
             caption = 'Age-specific cumulative effect of smoke on hosptializations.')
```

## Mortality 

Since we have mortality data, I'm also going to evaluate the association between grid-level smoke PM2.5 and cardiopulmonary mortality. I've created time-stratified case-crossover data frames of cardiopulmonary mortality events with referent period within the same month. I've also limit mortality case-crossover events to Front Range counties from May to October from 2010 to 2015.

```{r mortality}
# load casecrossover list -----
load("../../data/health/co_mortality_cc_list.RData")
# load mortality outcome list
load("../../data/health/icd10_outcome.RData")
```

```{r colorado_mortality_list}
# extract a vector of outcome names from the icd10 outcomes list 
outcomes <- names(icd10_outcomes)

# reduce case-crossover list to only summer months and join pm
co_mortality_list <- casecross_list %>% 
  # desired format to make sure it's right
  map(~ mutate(., outcome = as.numeric(as.character(outcome)),
               date = as.Date(as.character(date_of_death)),
               month = as.factor(lubridate::month(date))) %>% 
      # filter out 2016; I don't have pm data yet
      filter(date <= "2015-12-30") %>% 
      filter(fips %in% fr_fips)) %>% 
  # add outcome name to each dataframe
  map2(.x = ., .y = outcomes, ~mutate(.x, out_name = .y))
```

### Time Series of Respiratory and Cardiovascular Deaths in Colorado 

Time series of events for respiratory and cvd only. I also aggregated across front range counties for sufficient numbers. Looking for any potential time trends that may need to be accounted for.

```{r ts_death_counts}
# estimate deaths 
ts_death <- co_mortality_list %>% 
  map_dfr(. , function(df){
    counts <- df %>% 
      filter(outcome == 1) %>% 
      group_by(out_name, date) %>% 
      summarise(n = n())
    }) %>% 
  filter(out_name %in% c('resp', 'cvd'))
```

Mortality time-series plot.

```{r ts_death_plots}
ts_death_plot <- ggplot(data=ts_death, aes(x=date, y=n)) +
  geom_point() +
  facet_wrap(~out_name) +
  theme_minimal()

ts_death_plot
```

There is a general increase in cardiovascular deaths over time, which I'm guessing corresponds with the population increase of Colorado. Rates probably would show a more stable rate. Interesting observation in the respiratory related morbidity is the spike at the end of 2014, which I think is because of the bad flu season. I remember Kirk saying this.

I am going to limit mortality to May to October months in 2010 to 2015 and join with PM2.5 estimates.

```{r death_pm}
# extract names
cause_death <- c('Respiratory', 'Asthma', 'COPD', 'CVD', 'Heart Failure',
                 'Cardiac Arrest', 'Ischemic Heart Disease', 
                 'Myocardial Infarction', 'Cerebrovascular')

# reduce case-crossover list to only summer months and join GRID ID
co_death_list <- co_mortality_list %>% 
  # filter out 2016; I don't have pm data yet
  map(~ filter(., date <= "2015-12-30") %>% 
      filter(month %in% 5:10) %>% 
      filter(fips %in% fr_fips) %>% 
      mutate(WRFGRID_ID = as.character(wrfgrid_id),
             # age category
             age_cat = case_when(age < 15 ~ 'age_under_15',
                                 age >= 15 & age < 65 ~ 'age_15_to_65',
                                 age >= 65 ~ 'age_over_65')) %>% 
      select(-month, -wrfgrid_id) %>%
      # join with grid key
      left_join(grid_key, by = 'WRFGRID_ID') %>% 
      left_join(co_pm, by = c("fips", "date")) %>% 
      # left join grid pm
      left_join(grid_pm, by = c("GRID_ID", "date")) %>% 
      left_join(ozone, by = c("GRID_ID", "date"))) %>% 
  # add outcome name to each dataframe
  map2(.x = ., .y = cause_death, ~mutate(.x, out_name = .y))
```

### Strata Counts
Number of cardiopulmonary deaths in Front Range counties during this time period.

```{r death_counts}
strata <- c('All', 'Sex', 'Age')

# estimate deaths 
death_counts <- co_death_list %>% 
  map_dfr(.,function(df){
    map_dfr(strata, function(x){
    if(x == 'All'){
      counts <- df %>% 
        filter(outcome == 1) %>% 
        group_by(out_name) %>% 
        summarise(n_events = n()) %>% 
        mutate(strata = x) %>% 
        select(out_name, strata, n_events)
    } else if(x == 'Sex'){
      counts <- df %>% 
        filter(outcome == 1) %>% 
        group_by(out_name, sex) %>% 
        summarise(n_events = n()) %>% 
        rename(strata = sex) %>% 
        select(out_name, strata, n_events)
    } else {
      counts <- df %>% 
        filter(outcome == 1) %>% 
        group_by(out_name, age_cat) %>% 
        summarise(n_events = n()) %>% 
        rename(strata = age_cat) %>% 
        select(out_name, strata, n_events)
    }
    }) # end strata map
  }) %>% # end outcome list map
  spread(strata, n_events) %>% 
  select(out_name, All, F, M, age_under_15, age_15_to_65, age_over_65) %>% 
  mutate_at(vars(F:age_over_65), funs(round((./All)*100,1)))

# print death counts
knitr::kable(death_counts, caption='Front Range Cardiopulmonary Deaths and Strata Proportion')
```

Assessing how many CVD deaths are missing a grid assignment but were assigned a county PM2.5. Not that many missing (~2%).

```{r death_missing_grid}
missing <- co_death_list[[4]] %>% 
  filter(outcome == 1) %>% 
  mutate(county_miss = ifelse(is.na(pm_krig), 1, 0),
         grid_miss = ifelse(is.na(pm25_grid), 1, 0)) %>% 
  group_by(county_miss, grid_miss) %>% 
  summarize(n = n()) %>% 
  mutate(prop = round(n/(17720+402),2))

knitr::kable(missing, caption = 'CVD mortality missing grid PM2.5')
```

### Same Day Association between Smoke and Death

Same analysis as hospitalizations where likelihood of a cardiopulmonary death is regressed a 10 ug/m^3 increase in smoke PM2.5. Model accounts for within subject variability and adjusts for temperature.

```{r sameday_death}
# same day results
same_day_death <- co_death_list %>% 
  map_dfr(., function(df){
    out_name <- unique(df$out_name)
    result <- broom::tidy(clogit(outcome ~ gpm_smk10unit + o3_8hr_max_ppb + 
                                 temp_f_grid + strata(id),
                                 data = df)) %>% 
      filter(term == 'gpm_smk10unit') %>% 
      select(term, estimate, conf.low, conf.high) %>% 
      mutate_at(vars(estimate:conf.high), exp) %>% 
      mutate(outcome_name = out_name)
  }) %>% 
  mutate(outcome_name = forcats::fct_relevel(outcome_name, .$outcome_name),
         group = as.factor(ifelse(outcome_name %in% c('Respiratory', 'Asthma', 'COPD'),
                        'Respiratory', 'Cardiovascular')))
```

Mortality same day association plot. 

```{r death_sameday_plot}
death_plot <- ggplot(data=same_day_death, aes(x=outcome_name, y = estimate, 
                                              colour = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=conf.low, ymax=conf.high), width = 0.3) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Underlying Cause of Death") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=0.95, vjust = 0.75))

print(death_plot)
```

Note there are very few deaths with underlying cause of death as asthma and cardiac arrest and thus a lot of variability. I'm going to plot without these two outcomes so it's easier to read.

Underlying cause of death plot I'll use in the paper. 

```{r death_plot2}
death_plot2 <- ggplot(data = filter(same_day_death, 
                                    !(outcome_name %in% c('Asthma', 'Cardiac Arrest'))),  
                                    aes(x=outcome_name, y = estimate, colour = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=conf.low, ymax=conf.high), width = 0.3) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Underlying Cause of Death") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=0.95, vjust = 0.75))

print(death_plot2)
```

No significant associations with a 10 ug/m^3 increase in smoke PM2.5 and cardiopulmonary morbidity.

Here is a table of the same-day mortality association.

```{r sameday_mortality_tab}
knitr::kable(select(same_day_death, outcome_name, estimate:conf.high),
             caption = "Same Day Association with Smoke and Mortality")
```


### Cumulative effect for a > 10 ug/m^3 of smoke exposure over 4 days on risk of death

Looking at cumulative exposure of 0 to 3 days of smoke exposure on risk for cardiopulmonary death.

```{r mortality_results}
cod <- rep(cause_death, each = 8)

dl_death_results  <- lapply(co_death_list, function(x){
  # output dataframe from list
  data <- x %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  
  # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + o3_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(cod), .) 
```

Cumulative effect death.

```{r death_cumulative}
cumulative_death_results <- filter(dl_death_results, 
                                   type == 'cumulative' & time == 3) %>% 
    select(-strata, -time) %>% 
    mutate(outcome = forcats::fct_relevel(cod, cause_death),
         group = as.factor(if_else(cod %in% cause_death[1:3],
         "Respiratory", "Cardiovascular"))) %>% 
    filter(!(outcome %in% c('Asthma', 'Cardiac Arrest')))
```

Plot of cumulative effect.
```{r cumulative_death_plot}
# plot
cumulative_death_plot <- ggplot(data = cumulative_death_results, 
               aes(x=outcome, y = odds_ratio, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.3) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10 ", mu,"g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Outcome") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=0.95, vjust = 0.75,
                                   size = 10))

print(cumulative_death_plot)
```

Removed asthma and cardiac arrest as they were highly variable.

Table of the cumulative effects of smoke on underlying cause of death.

```{r cumulative_mortality_table}
knitr::kable(select(cumulative_death_results,outcome, odds_ratio:upper_95),
             caption = "Cumulative Effect of Smoke on Mortality")
```

### Distributed Lag Estiamtes for Mortality

Plot of daily estimates from the distributed lag model for mortality. 

```{r constrained_lag_results_death}
constrained_lag_results_death <- dl_death_results %>% 
  mutate(outcome = forcats::fct_relevel(cod, cause_death),
         group = as.factor(if_else(cod %in% cause_death[1:3],
         "Respiratory", "Cardiovascular"))) %>% 
  filter(!(outcome %in% c('Asthma', 'Cardiac Arrest'))) %>% 
  filter(type == 'lag')

# constrained distributed lag
dl_death_plot <- ggplot(data=constrained_lag_results_death, 
    aes(x=time, y=odds_ratio, group = group, color = group, fill = group)) +
  geom_line(size = 1) +
  geom_ribbon(aes(ymin = lower_95, ymax = upper_95), color = 'transparent',
              alpha = 0.5) +
  facet_wrap(~outcome, scales = 'free_y', ncol = 4) +
  scale_color_manual("Underlying Cause of Death", values = c("#ff00cc", "darkblue")) +
  scale_fill_manual("Underlying Cause of Death", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Lagged Days") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        legend.direction = 'horizontal',
        legend.position = 'bottom',
        panel.grid.minor = element_blank(),
        strip.background = element_blank())

print(dl_death_plot)
```

If you look at the effect sizes, I do think there may be some interesting associations with all cause respiratory and CVD. It also appears that maybe heart attacks and strokes could be increased on the day of smoke exposure.

Daily distributed lagged estimates table.

```{r dl_lag_death_table}
knitr::kable(select(constrained_lag_results_death, outcome, time:upper_95),
             caption = 'Lagged Associations between Smoke and Underlying Cause of Death')
```


### Unconstrained Lag

Unconstrained lag for mortality.

```{r unconstrained_lag_death}
# repeat outcomes 4 times
ucod <- rep(cause_death, each = 4)
# day to repeat
day <- rep(0:3, times = 9)

# lag day vector
lag_days <- c('', '_lag1', '_lag2', '_lag3')

# map across lagged days
death_uc_lag_results <- map_dfr(co_death_list, function(df){
  data <- df
    results <- map_dfr(lag_days, function(x){
      # define function
      f <- as.formula(paste('outcome~',
        paste(paste0(c('gpm_smk10unit', 'o3_8hr_max_ppb', 'temp_f_grid'), 
                     x), collapse = '+'),
        '+strata(id)'))
      r <- broom::tidy(clogit(f, data = data)) %>% 
      filter(term == paste0('gpm_smk10unit',x)) %>% 
      select(term, estimate, conf.low, conf.high) %>% 
      mutate_at(vars(estimate:conf.high), exp)
    })
  }) %>% 
  cbind(ucod, day, .) %>% 
  mutate(outcome = forcats::fct_relevel(ucod, cause_death),
         group = as.factor(if_else(outcome %in% cause_death[1:3],
         "Respiratory", "Cardiovascular"))) 
```

Plot for unconstrained lag.

```{r death_uc_lag_plot}
death_uc_plot <- ggplot(data=death_uc_lag_results, aes(x=day, y=estimate, 
                                                group = group, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=conf.low, ymax=conf.high), width = 0.3) +
  facet_wrap(~outcome, scales = 'free_y', ncol = 4) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Lagged Days") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        legend.direction = 'horizontal',
        legend.position = 'bottom',
        panel.grid.minor = element_blank(),
        strip.background = element_blank())

print(death_uc_plot)
```

Table for unconstrained lag values.

```{r death_uc_lag_table}
knitr::kable(select(death_uc_lag_results, ucod, day, estimate:conf.high),
             caption = 'Uncontrained Lag Association between Smoke and Underlying Cause of Death')
```

### Sex-Specific Stratification

Using the distributed lag model for each sex strata. Also modifying code to pull out n cases analyzed.

```{r sex_dl_death_results}
# estimating lagged effects
ucod <- rep(cause_death, each = 16)

sex_strata <- c('F', 'M')

sex_death_results  <- map_dfr(co_death_list, function(df){
  results <- map_dfr(sex_strata, function(x){
   data <- df %>% 
     filter(sex == x) %>% 
     mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))
   
    # create lagged matrix
    pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
    # temp matrix
    temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                                 temp_f_grid_lag2, temp_f_grid_lag3))
    
    # ozone matrix
    o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                               o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
    
    # define lagged basis spline
    exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
    # pm basis
    pm_basis <- pm_mat %*% exp_b
    # temp basis
    temp_basis <- temp_mat %*% exp_b
    # ozone basis
    o3_basis <- o3_mat %*% exp_b
    # run lagged model
    lag_mod <- clogit(outcome ~ pm_basis + o3_basis + temp_basis + strata(id), 
                      data = data)
  
    # estimate lag estimate
    lag_est <- distribute_that_lag(lag_mod, strata = "pm") %>% 
      mutate(sex = x)
    return(lag_est)
  }) 
}) %>% 
  # bind in outcome names
  bind_cols(data.frame(ucod), .) 
```

Sex-specific plots of the cumulative effect.

```{r sex_strata_plot_death}
# subset to cumulative results
cumulative_sex_death_strata <- sex_death_results %>% 
  filter(type == 'cumulative' & time == 3) %>% 
  mutate(sex_long = if_else(sex == 'F', 'Female', 'Male'),
         outcome = forcats::fct_relevel(ucod, cause_death),
         group = as.factor(if_else(ucod %in% cause_death[1:3],
         "Respiratory", "Cardiovascular"))) %>% 
  filter(!(outcome %in% c('Asthma', 'Cardiac Arrest'))) 

# plot
sex_plot <- ggplot(data=cumulative_sex_death_strata, aes(x=sex_long, y=odds_ratio, 
                                        group = group, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.3) +
  facet_wrap(~outcome, scales = 'free_y', ncol = 4) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Sex") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        legend.direction = 'horizontal',
        legend.position = 'bottom',
        panel.grid.minor = element_blank(),
        strip.background = element_blank())

print(sex_plot)
```

Sex-specific estimates table.

```{r sex_strata_table_death}
knitr::kable(select(cumulative_sex_strata, outcome, sex_long, odds_ratio:upper_95),
             caption = 'Sex-specific cumulative effect of smoke on hosptializations.')
```

### Age-Specific Estimates

```{r age_strata_death}
# repeat cause of death name 
ucod <- rep(cause_death[c(1,4)], each = 24)

# define age strata to loop through
age_strata <- c('age_under_15', 'age_15_to_65', 'age_over_65')

age_death_results  <- map_dfr(co_death_list[c(1,4)], function(df){
  results <- map_dfr(age_strata, function(x){
   data <- df %>% 
     filter(age_cat == x) %>% 
     mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))
   
    # create lagged matrix
    pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
    # temp matrix
    temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                                 temp_f_grid_lag2, temp_f_grid_lag3))
    
    # ozone matrix
    o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                               o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
    
    # define lagged basis spline
    exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
    # pm basis
    pm_basis <- pm_mat %*% exp_b
    # temp basis
    temp_basis <- temp_mat %*% exp_b
    # ozone basis
    o3_basis <- o3_mat %*% exp_b
    # run lagged model
    lag_mod <- clogit(outcome ~ pm_basis + o3_basis + temp_basis + strata(id), 
                      data = data)
  
    # estimate lag estimate
    lag_est <- distribute_that_lag(lag_mod, strata = "pm") %>% 
      mutate(age_cat = x)
    return(lag_est)
  }) 
}) %>% 
  bind_cols(data.frame(ucod), .)
```
Age-specific plots of the cumulative effect.I'm going to cut out deaths under 15 because there aren't many of them and the variance is high.

```{r age_death_strata_plot}
# subset to cumulative results
cumulative_age_death_strata <- age_death_results %>% 
  filter(type == 'cumulative' & time == 3) %>% 
  filter(age_cat != 'age_under_15') %>% 
  mutate(age_long = forcats::fct_relevel(
    case_when(age_cat == 'age_under_15' ~ 'Age < 15',
              age_cat == 'age_15_to_65' ~ 'Age 15 to 64',
              age_cat == 'age_over_65' ~ 'Age > 64'),
    c('Age < 15', 'Age 15 to 64', 'Age > 64')),
    outcome = forcats::fct_relevel(if_else(ucod == 'Respiratory', 'Respiratory',
                                           'Cardiovascular'), 
                                   c('Cardiovascular', 'Respiratory')))

# plot
age_plot <- ggplot(data=cumulative_age_death_strata, aes(x=age_long, y=odds_ratio, 
                                        group = outcome, color = outcome)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.3) +
  facet_wrap(~outcome, scales = 'free_y', ncol = 4) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Age") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        legend.direction = 'horizontal',
        legend.position = 'bottom',
        panel.grid.minor = element_blank(),
        strip.background = element_blank())

print(age_plot)
```

Table of age-specific associations.

```{r age_specific_death_tabs}
knitr::kable(select(cumulative_age_death_strata, 
                    outcome, age_long, odds_ratio:upper_95),
             caption = 'Age-specific associations between smoke and underlying cause of death')
```

## Binary Smoke Classifier

The continuous definition of smoke may have some misclassification bias, particularly where there is difficulty distinguishing from PM2.5 impacted by smoke and a high anthropocentric PM2.5 day that also happens to have some smoke in the atmospheric column. I am going to try out a binary outcome of > 10 ug/m^3 PM2.5 with HMS overhead as a binary indicator for smoke and look at the association between multiple days of a binary smoke exposure and the risk of cardiopulmonary morbidity.

### Hospitalizations and Binary Smoke

```{r binary_hosp_results}
out_rep <- rep(outcome, each = 8)

hosp_binary_results  <- lapply(co_hosp_list, function(x){
  # output dataframe from list
  data <- x %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gsmk10_hms_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gsmk10_hms, gsmk10_hms_lag1, 
                             gsmk10_hms_lag2, gsmk10_hms_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  temp_basis <-
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(out_rep), .) 
```

```{r binary_cumulative_plot}
# get the cumulative effect over 4 days
cumulative_bin_results <- filter(hosp_binary_results, 
                                 type == 'cumulative' & time == 3) %>% 
    select(-strata, -time) %>% 
    mutate(outcome = forcats::fct_relevel(outcome, out_order),
         group = as.factor(if_else(outcome %in% out_order[1:5],
         "Respiratory", "Cardiovascular")))

# plot
cbin_hosp_plot <- ggplot(data = cumulative_bin_results, 
               aes(x=outcome, y = odds_ratio, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.3) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: Smoke PM"[2.5], " > 10 ug/m"^3))) +
  xlab("Outcome") +
  ggtitle("Hospitalization Cumulative Smoke Exposure 0 to 4 Days") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=0.95, vjust = 0.75,
                                   size = 10))

print(cbin_hosp_plot)
```

There is a significant association with this binary cutoff and asthma over 0 to 4 days. Some of the cardiovascular outcomes that were trending towards 'significance' were attenuated to the null here. 

### Mortality

```{r binary_death_results}
cod <- rep(cause_death, each = 8)

binary_death_results  <- lapply(co_death_list, function(x){
  # output dataframe from list
  data <- x %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gsmk10_hms, gsmk10_hms_lag1, 
                             gsmk10_hms_lag2, gsmk10_hms_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  temp_basis <-
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(cod), .) 
```

```{r binary_cumulative_death}
# get the cumulative effect over 4 days
c_bin_death_results <- filter(binary_death_results, 
                                   type == 'cumulative' & time == 3) %>% 
    select(-strata, -time) %>% 
    mutate(outcome = forcats::fct_relevel(cod, cause_death),
         group = as.factor(if_else(cod %in% cause_death[1:3],
         "Respiratory", "Cardiovascular"))) %>% 
    filter(!(outcome %in% c('Asthma', 'Cardiac Arrest')))

# plot
cbin_death_plot <- ggplot(data = c_bin_death_results, 
               aes(x=outcome, y = odds_ratio, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.3) +
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: Smoke PM"[2.5], " > 10 ug/m"^3))) +
  xlab("Outcome") +
  ggtitle("Mortality Cumulative Smoke Exposure 0 to 4 Days") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=0.95, vjust = 0.75,
                                   size = 10))

print(cbin_death_plot)
```

No association with mortality.

## Fire/Smoke Event-Specific

Looking at specific fires. I think isolating to specific counties impacted by specific fires gives me more confidence in the kriged models to understand the exposure series. We've also used this approach in Washington and Oregon studies. I'm going to run separate models in each section, but plot estimates side by side in a couple plots.

Since there are fewer deaths for some of the subcategories and I'm reducing further to specific times and counties, I'm going to only look at respiratory and cardiovascular general categories of underlying cause of death.

### Four-Mile Canyon Fire 2010

The first fire I'll look at is the Four-Mile Canyon Fire that occurred west of Boulder. It started on September 7, 2010 and contained on September 13th. I will limit the time frame to 2010-05-01 to 2010-10-31 and to Boulder County only. I'm open to adding additional counties known to be impacted by wildfire smoke.

```{r fourmile_hosp_results}
out_rep <- rep(outcome, each = 8)

mile4_hosp_cont <-lapply(co_hosp_list, function(x){
  # output dataframe from list
  data <- x %>% 
    # filter to boulder
    filter(fips.x == '08013') %>% 
    filter(date >= '2010-05-01' & date <= '2010-10-31') %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
    # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + o3_basis + strata(id), data = data)
  
  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(out_rep), .) %>% 
  mutate(event = 'Four Mile 2010')
```

```{r mile4_deaths}
cod <- rep(names(co_death_list[c(1,4)]), each=8)

mile4_death_cont <- lapply(co_death_list[c(1,4)], function(x){
  # output dataframe from list
  data <- x %>%     
    # filter to boulder
    filter(fips.x == '08013') %>% 
    filter(date >= '2010-05-01' & date <= '2010-10-31') %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  
  # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + o3_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(cod), .) %>% 
  mutate(event = 'Four Mile 2010')
```

### Waldo Canyon 2012

Waldo Canyon started on June 23rd 2012 and burned until July 10th 2012 near Colorado Springs. Limiting to events from El Paso County to assess impact of smoke. Are there other counties I should consider? 

Limiting hospitalizations and deaths to May 2012 through August 2012. I'm consider expanding time frame and other counties too. 
```{r waldo_hosp_results}
out_rep <- rep(outcome, each = 8)

waldo_hosp_cont <-lapply(co_hosp_list, function(x){
  # output dataframe from list
  data <- x %>% 
    # filter to el paso
    filter(fips.x == '08041') %>% 
    filter(date >= '2012-05-01' & date <= '2012-10-31') %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  
  # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + o3_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(out_rep), .) %>% 
  mutate(event = 'Waldo Canyon 2012')
```


```{r waldo_death_results}
cod <- rep(names(co_death_list[c(1,4)]), each=8)

waldo_death_cont <- lapply(co_death_list[c(1,4)], function(x){
  # output dataframe from list
  data <- x %>%     
    # filter to el paso
    filter(fips.x == '08041') %>% 
    filter(date >= '2012-05-01' & date <= '2012-10-31') %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  
  # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + o3_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(cod), .) %>% 
  mutate(event = 'Waldo Canyon 2012')
```

### High Park Fire

For this fire, I'm limiting hospitalizations and deaths to May 2012 through August 2012 occurring in Larmier county.

```{r highpark_hosp_results}
out_rep <- rep(outcome, each = 8)

hipark_hosp_cont <-lapply(co_hosp_list, function(x){
  # output dataframe from list
  data <- x %>% 
    # filter to larimer
    filter(fips.x == '08069') %>% 
    filter(date >= '2012-05-01' & date <= '2012-10-31') %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + o3_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(out_rep), .) %>% 
  mutate(event = 'High Park 2012')
```

```{r hipark_deaths}
cod <- rep(names(co_death_list[c(1,4)]), each=8)

hipark_death_cont <- lapply(co_death_list[c(1,4)], function(x){
  # output dataframe from list
  data <- x %>%     
    # filter to el paso
    filter(fips.x == '08069') %>% 
    filter(date >= '2012-05-01' & date <= '2012-10-31') %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
    # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + o3_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(cod), .) %>% 
  mutate(event = 'High Park 2012')
```

### 2012 Local Smoke

2012 local fires for all grid cells in study domain.
```{r local_hosp_results}
out_rep <- rep(outcome, each = 8)

local_hosp_cont <-lapply(co_hosp_list, function(x){
  # output dataframe from list
  data <- x %>% 
    filter(date >= '2012-05-01' & date <= '2012-10-31') %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + o3_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(out_rep), .) %>% 
  mutate(event = 'Local 2012')
```

```{r local_deaths}
cod <- rep(names(co_death_list[c(1,4)]), each=8)

local_death_cont <- lapply(co_death_list[c(1,4)], function(x){
  # output dataframe from list
  data <- x %>%     
    filter(date >= '2012-05-01' & date <= '2012-10-31') %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + o3_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(cod), .) %>% 
  mutate(event = 'Local 2012')
```

### 2015 Transported Smoke

Fires in Canada and Washington led to the transported smoke event that affected the Front Range communities in Colorado in 2015. I have limited this analysis to 2015-05-01 to 2015-10-31 (note hospitalizations only go until 2015-10-01). I included all Front Range counties.

```{r transport_hosp_results}
out_rep <- rep(outcome, each = 8)

trans_hosp_cont <-lapply(co_hosp_list, function(x){
  # output dataframe from list
  data <- x %>% 
    filter(date >= '2015-05-01' & date <= '2015-10-31') %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + o3_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(out_rep), .) %>% 
  mutate(event = 'Transport 2015')
```

```{r transport_deaths}
cod <- rep(names(co_death_list[c(1,4)]), each=8)

trans_death_cont <- lapply(co_death_list[c(1,4)], function(x){
  # output dataframe from list
  data <- x %>%     
    filter(date >= '2015-05-01' & date <= '2015-10-31') %>% 
    mutate(date = as.Date(date),
           outcome = as.numeric(as.character(outcome))) %>%
    # remove missing lagged data
    filter(!is.na(gpm_smk10unit_lag3))

  # create lagged matrix
  pm_mat <- as.matrix(select(data, gpm_smk10unit, gpm_smk10unit_lag1, 
                             gpm_smk10unit_lag2, gpm_smk10unit_lag3))
  
  # temp matrix
  temp_mat <- as.matrix(select(data, temp_f_grid, temp_f_grid_lag1,
                               temp_f_grid_lag2, temp_f_grid_lag3))
  # ozone matrix
  o3_mat <- as.matrix(select(data, o3_8hr_max_ppb, o3_8hr_max_ppb_lag1,
                             o3_8hr_max_ppb_lag2, o3_8hr_max_ppb_lag3))
  
  # define lagged basis spline
  exp_b <- splines::ns(0:(ncol(pm_mat)-1), df = 3, intercept = T)
  # pm basis
  pm_basis <- pm_mat %*% exp_b
  # temp basis
  temp_basis <- temp_mat %*% exp_b
  # ozone basis
  o3_basis <- o3_mat %*% exp_b
  
  # run lagged model
  lag_mod <- clogit(outcome ~ pm_basis + temp_basis + o3_basis + strata(id), data = data)

  # estimate lag estimate
  lag_est <- distribute_that_lag(lag_mod, strata = "pm") 
  return(lag_est)
  }) %>%  #end lappply
  # bind rows
  map_dfr(.,rbind) %>% 
  # bind in outcome names
  bind_cols(data.frame(cod), .) %>% 
  mutate(event = 'Transport 2015')
```

### Different Event and Hospitalization Plots

Plots of association for each hospitalization outcome by event. I left out Four Mile Canyon fire since there were so few events the estimates were unstable. This can probably be fixed by adding in other counties that were impacted by smoke.

```{r hosp_event_plot}
# bind event dataframes together
hosp_event <- bind_rows(waldo_hosp_cont, hipark_hosp_cont, local_hosp_cont,
                        trans_hosp_cont) %>% 
  filter(type == 'cumulative' & time == 3) %>% 
  select(-strata, -time) %>% 
  mutate(outcome = forcats::fct_relevel(out_rep, out_order),
         group = as.factor(if_else(outcome %in% out_order[1:5],
         "Respiratory", "Cardiovascular")),
         # ordering fire event
         event = forcats::fct_relevel(event, c('Waldo Canyon 2012', 'High Park 2012',
                                               'Local 2012', 'Transport 2012'))) %>% 
  # filter out acute bronchitis
  filter(outcome != 'Acute Bronchitis')

# plot
hosp_event_plot <- ggplot(data = hosp_event, 
                          aes(x=outcome, y=odds_ratio, color = group)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  facet_wrap(~event, scales = 'free_y') +  
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Outcome") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank(),        
        legend.direction = 'horizontal',
        legend.position = 'bottom',
        strip.background = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=0.95, vjust = 0.75,
                                   size = 10))
  
print(hosp_event_plot)
```

I think this plot is kind of interesting for asthma, where there is a positive association with the 2015 transport smoke and an inverse association with the 2012 local fires for the study domain. I don't see an association with the individual fires, which may suggest the inverse association may be due to exposure misclassification? Or it could be real where poeple are taking risk-avoiding behaviors.I think Sheryl and I hypothesized that there might be an effect here because the first couple days of the smoke event were really hard to tell there was actual smoke and not fog. Also note that I included all front range counties because there were air quality warning up and down the front range. I think we could also do a 2012 to 2015 comparison. This might actually be the cleanest way to do this analysis, with the argument that the Front Range was impacted by smoke from two large fires in 2012 and impacted by smoke from transported smoke.

I left out Four Mile Canyon fire for now since the estimates were unstable due to few events.

Printing out fire events hospitalization table.
```{r fire_events_hosp_table}
knitr::kable(select(hosp_event, event, outcome, odds_ratio:upper_95),
             caption = 'Cumulative association between smoke from specific events and hospitalizations')
```


Plotting underlying cause of death by fire events.

```{r mortality_event_plot}
# bind event dataframes together
death_event <- bind_rows(waldo_death_cont, hipark_death_cont, local_death_cont,
                        trans_death_cont) %>% 
  filter(type == 'cumulative' & time == 3) %>% 
  select(-strata, -time) %>% 
  mutate(outcome = as.factor(if_else(cod == 'resp', 
                                     'Respiratory', 'Cardiovascular')),
         # ordering fire event
         event = forcats::fct_relevel(event, c('Waldo Canyon 2012', 'High Park 2012',
                                               'Local 2012', 'Transport 2012'))) 

# plot
death_event_plot <- ggplot(data = death_event, 
                          aes(x=outcome, y=odds_ratio, color = outcome)) +
  geom_point() +
  geom_errorbar(aes(ymin=lower_95, ymax=upper_95), width = 0.3) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  facet_wrap(~event) +  
  scale_color_manual("Cardiopulmonary", values = c("#ff00cc", "darkblue")) +
  geom_hline(yintercept = 1, linetype = "dashed", colour = "red") +
  ylab(expression(paste("Odds Ratio: 10", mu, "g/m"^3, " Increase in Smoke PM"[2.5]))) +
  xlab("Outcome") +
  theme_bw()+
  theme(panel.grid.major.x = element_blank(),
        panel.grid.major.y = element_line(linetype = "dotted"),
        panel.grid.minor = element_blank(),        
        legend.direction = 'horizontal',
        legend.position = 'bottom',
        strip.background = element_blank(),
        axis.text.x = element_text(angle = 45, hjust=0.95, vjust = 0.75,
                                   size = 10))
  
print(death_event_plot)
```

No association with deaths. 

Table for mortality for specific events.
```{r mortality_fire_event_table}
knitr::kable(select(death_event, outcome, event,odds_ratio:upper_95),
             caption = 'Cumulative association with smoke and mortality for specific events')
```


## Conclusions

I think there could be something interesting looking at 2012 vs. 2015 smoke, where transported smoke could be a risk factor. The hypothesis here could be that people are aware of smoke from local fires since they are publicized, where the transported smoke was not clear to people until there were air quality warnings. Mortality doesn't seem to be associated with these short-term smoke events.