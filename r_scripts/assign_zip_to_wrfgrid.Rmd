---
title: "Assigning boundaries and calculating proportion intersect for WRF-Grid"
author: "Ryan Gan"
date: "10/19/2017"
output: html_document
---

## Purpose

As part of the Colorado wildfire project and the American Lung Association project, I will need to assign ZIP code, county, and census track IDs to cells in the WRF-grid. 

Loading in the "tidyverse" and "sf"" package. A quick note about the "sf" package, I've suppressed warnings because it will often list this warning "although coordinates are longitude/latitude, it is assumed that they are planar" when performing functions on two sf files. This is only really important for calculations close to the poles. Differences further away from the poles are negligible.

```{r setup}
library(tidyverse)
library(sf)
```

Bringing in WRF-Grid, ZIP code, county, and census tract shape files as simple features files using the "sf" package. I will return to ZIP since it might change year to year. Census might be okay since it might only change every decade? Sheena would probably know for sure.

```{r file imports}
# county grid
county_path <- "./data/shapefiles/colorado_county"
colorado_county <- st_read(dsn=county_path, layer="colorado_county") %>% 
  # make a general FIPS code
  mutate(FIPS = as.factor(paste0(STATEFP, COUNTYFP)))
# retrieve coordinate reference system from census shapefile
wgs84 <- st_crs(colorado_county)

# wrf grid
wrf_path <- "./data/shapefiles/co_grid_shp"
wrf_grid <- st_read(dsn=wrf_path, layer="co_grid")
# set crs of grid
st_crs(wrf_grid) <- wgs84

# census tract
# I'll look at census and zip in a bit

# lat/lon of power plants
plant_id <- c("pueblo", "colo_springs")
lat <- c(38.2081, 38.8244)
lon <- c(-104.5747, -104.8331)

plant_locations <- tibble(plant_id, lat, lon) 
```

# Assigning county

This should be the most straight-forward as counties are the largest boundary I'd like to assign and most grid cells should fall nicely in to one county polygon. I'll plot a map of Colorado counties and overlay the WRF grid using the development version of ggplot2 which contains "geom_sf" that works with simple features.

```{r county grid plot, eval=F, warning=F}
# plot colorado counties and overlay wrf-grid
m <- ggplot() +
  geom_sf(data = colorado_county, aes(fill=NAME)) +
  geom_sf(data = wrf_grid, alpha = 0) +
  theme_bw()

# print map
m
```

It took some time to print this map so I'm going to subset to the two counties where the two coal-fired power plants of interest for the American Lung Association study are located, El Paso (city of Colorado Springs) and Pueblo (city of Pueblo). It would also make a reasonable example for a vignette if I ever make a package.

Plot of the county boundaries and the grids that overlap the boundaries. I will eventually add the power plants and city locations.

```{r subset el paso and pueblo, warning=F}
# el paso = 041 and pueblo = 101
el_pueblo <- colorado_county %>% 
  filter(COUNTYFP == "041" | COUNTYFP == "101")
# subset grid to cells in county
el_pueblo_grid <- wrf_grid[el_pueblo,]
  
# map
m <- ggplot(data = el_pueblo) +
  geom_sf(aes(fill=NAME), alpha = 0.5) +
  geom_sf(data=el_pueblo_grid, alpha = 0) +
  geom_point(data=plant_locations, aes(x=lon, y=lat), colour = "red") +
  theme_bw()
# print map
m
```

## Custom functions

Create custom functions I'll use for this project. First is the "proportion_intersect" function that produces a dataframe of proportion intersect between grids and polygons. 

This dataframe can be used in two other functions: "grid_to_poly", and "prop_int_matrix".

grid_to_poly_id: function that finds the most like polygon ID (county, ZIP code, census) based on max proportion intersect of grid ID. 

prop_int_matrix: fucntion to produce a proportion-intersect matrix from population-weighting exposure values.

```{r custom function}
# proportion_intersect ----
# custom function (I should write this to a package)
proportion_intersect <- function(poly, poly_id, grid, grid_id){
  # enquo lazy eval
  poly_id <- enquo(poly_id)
  grid_id <- enquo(grid_id)
  # subset grid that contains poly_i
  grid_i <- grid[poly,]
  # proportion intersect
  intersect_sf <- st_intersection(grid_i, poly)
  # calculation of proportion intersect
  proportion <- as.numeric(st_area(intersect_sf)/st_area(grid_i)) %>% 
    data_frame() %>% rename(proportion = ".")
  # column bind the proportion to the intersect sf object
  output_df <- intersect_sf %>% 
    # eventually replace these with generic names
    select(!!grid_id, !!poly_id) %>% 
    bind_cols(proportion)
  # remove geometry
  st_geometry(output_df) <- NULL
  return(output_df)
}

# grid_to_poly ----
# note I want to find a way to do lazy eval for function names
# assign county (plan to add this functionality to function)
grid_to_poly <- function(prop_int_df, group_column) {
  # lazy eval needs enquo
  group_column <- enquo(group_column)
  # create dataframe
  grid_to_poly_df <- prop_int_df %>% 
    group_by(!!group_column) %>% 
    # take highest proportion
    slice(which.max(proportion)) %>% 
    # set proportion > 1 to 1
    mutate(proportion = ifelse(proportion > 1, 1, proportion))
  # return grid to poly df
  return(grid_to_poly_df)
}

```

I'll need to double check to make sure this process works. Takes about a minute to calculate proportion intersect for each county and WRF cell in state.

```{r county assignment}
# create dataframe of intersects and time computation
start_time <- Sys.time()
# proportion intersect for the entire state
co_county_df <- proportion_intersect(poly = colorado_county, poly_id = FIPS,
                                     grid = wrf_grid, grid_id = WRFGRID_ID)

stop_time <- Sys.time()
compute_time <- stop_time - start_time
compute_time

# grid to WRF id function
co_county_id2 <- grid_to_poly(co_county_df, WRFGRID_ID)

identical(co_county_id, co_county_id2)
# might as well create proportion intersect matrix as well
# i need to add back in the WRF IDs that were outside the state boundary
complete_wrf_id <- wrf_grid %>% 
  select(WRFGRID_ID) %>% 
  left_join(co_county_df, by = "WRFGRID_ID")
# remove sf geometry
st_geometry(complete_wrf_id) <- NULL

# create dataframe that can be used for population-weighting
co_county_pi <- complete_wrf_id %>% 
  # add a fips in front of each FIPS code to avoid variable with a leading 0
  mutate(FIPS = paste0("FIPS",FIPS)) %>% 
  spread(FIPS, proportion) %>% 
  # mutate missing to 0 at each fips variable
  mutate_at(vars(contains("FIPS")), funs(ifelse(is.na(.), 0, .))) %>% 
  # remove FIPS NA variable created by missing FIPS values in WRFGRIDS outside
  # of state bounding box
  select(-FIPSNA)

# write this file
write_path <- "./data/smoke/colo_county_prop_int.csv"
write_csv(co_county_pi, write_path)

```
