---
title: "Assigning boundaries and calculating proportion intersect for WRF-Grid"
author: "Ryan Gan"
date: "10/19/2017"
output: html_document
---

## Purpose

As part of the Colorado wildfire project and the American Lung Association project, I will need to assign ZIP code, county, and census track IDs to cells in the WRF-grid. 

Loading in the "tidyverse" and "sf"" package. A quick note about the "sf" package, I've suppressed warnings because it will often list this warning "although coordinates are longitude/latitude, it is assumed that they are planar" when performing functions on two sf files. This is only really important for calculations close to the poles. Differences further away from the poles are negligible.

```{r setup}
library(tidyverse)
library(sf)
```

Bringing in WRF-Grid, ZIP code, county, and census tract shape files as simple features files using the "sf" package. I will return to ZIP since it might change year to year. Census might be okay since it might only change every decade? Sheena would probably know for sure.

```{r file imports}
# county grid ----
county_path <- "./data/shapefiles/colorado_county"
colorado_county <- st_read(dsn=county_path, layer="colorado_county") %>% 
  # make a general FIPS code
  mutate(FIPS = as.factor(paste0(STATEFP, COUNTYFP)))
# retrieve coordinate reference system from census shapefile
#wgs84 <- st_crs(colorado_county)

# census tract ----
census_path <- "./data/shapefiles/ACS_2015_5YR_TRACT_CO"
colorado_census <- st_read(dsn=census_path, layer="ACS_2015_5YR_TRACT_CO")
# retrieve coordinate ref system from census tract
nad83 <- st_crs(colorado_census)

# wrf grid ----
wrf_path <- "./data/shapefiles/co_grid_shp"
wrf_grid <- st_read(dsn=wrf_path, layer="co_grid")
# set crs of grid and county to nad83 to be the same
st_crs(wrf_grid) <- nad83
colorado_county <- st_transform(colorado_county, nad83) 

# lat/lon of power plants ----
plant_id <- c("pueblo", "colo_springs")
lat <- c(38.2081, 38.8244)
lon <- c(-104.5747, -104.8331)

plant_locations <- tibble(plant_id, lat, lon) 
```

# Assigning county

This should be the most straight-forward as counties are the largest boundary I'd like to assign and most grid cells should fall nicely in to one county polygon. I'll plot a map of Colorado counties and overlay the WRF grid using the development version of ggplot2 which contains "geom_sf" that works with simple features.

```{r county grid plot, eval=F, warning=F}
# plot colorado counties and overlay wrf-grid
m <- ggplot() +
  geom_sf(data = colorado_county, aes(fill=NAME)) +
  geom_sf(data = wrf_grid, alpha = 0) +
  theme_bw()

# print map
m
```

It took some time to print this map so I'm going to subset to the two counties where the two coal-fired power plants of interest for the American Lung Association study are located, El Paso (city of Colorado Springs) and Pueblo (city of Pueblo). It would also make a reasonable example for a vignette if I ever make a package.

Plot of the county boundaries and the grids that overlap the boundaries. I will eventually add the power plants and city locations.

```{r subset el paso and pueblo, warning=F}
# el paso = 041 and pueblo = 101
el_pueblo <- colorado_county %>% 
  filter(COUNTYFP == "041" | COUNTYFP == "101")
# subset grid to cells in county
el_pueblo_grid <- wrf_grid[el_pueblo,]
  
# map
m <- ggplot(data = el_pueblo) +
  geom_sf(aes(fill=NAME), alpha = 0.5) +
  geom_sf(data=el_pueblo_grid, alpha = 0) +
  geom_point(data=plant_locations, aes(x=lon, y=lat), colour = "red") +
  theme_bw()
# print map
m
```

## Custom functions

Create custom functions I'll use for this project. First is the "proportion_intersect" function that produces a dataframe of proportion intersect between grids and polygons. 

This dataframe can be used in two other functions: "grid_to_poly", and "prop_int_matrix".

grid_to_poly_id: function that finds the most like polygon ID (county, ZIP code, census) based on max proportion intersect of grid ID. 

prop_int_matrix: fucntion to produce a proportion-intersect matrix from population-weighting exposure values.

```{r custom function}
# proportion_intersect ----
# custom function (I should write this to a package)
proportion_intersect <- function(poly_sf, poly_id, grid_sf, grid_id){
  # enquo lazy eval
  poly_id <- enquo(poly_id)
  grid_id <- enquo(grid_id)
  # subset grid that contains poly_i
  grid_i <- grid_sf[poly_sf,]
  # proportion intersect
  intersect_sf <- st_intersection(grid_i, poly_sf)
  # calculation of proportion intersect
  proportion <- as.numeric(st_area(intersect_sf)/st_area(grid_i)) %>% 
    data_frame() %>% rename(proportion = ".")
  # column bind the proportion to the intersect sf object
  output_df <- intersect_sf %>% 
    # eventually replace these with generic names
    select(!!grid_id, !!poly_id) %>% 
    bind_cols(proportion)
  # remove geometry
  st_geometry(output_df) <- NULL
  return(output_df)
}

# grid_to_poly ----
# note I want to find a way to do lazy eval for function names
# assign county (plan to add this functionality to function)
grid_to_poly <- function(prop_int_df, group_column) {
  # lazy eval needs enquo
  group_column <- enquo(group_column)
  # create dataframe
  grid_to_poly_df <- prop_int_df %>% 
    group_by(!!group_column) %>% 
    # take highest proportion
    slice(which.max(proportion)) %>% 
    # set proportion > 1 to 1
    mutate(proportion = ifelse(proportion > 1, 1, proportion))
  # return grid to poly df
  return(grid_to_poly_df)
}

# proportion intersect data frame ----
# this custom function creates the proportion intersect data frame that can be
# converted to a matrix for population-weighting
pi_matrix <- function(grid_sf, grid_id, prop_int_df, poly_id){
  # lazy eval variables
  grid_id <- enquo(grid_id)
  poly_id <- enquo(poly_id)

  
  # remove geometry object from grid
  st_geometry(grid_sf) <- NULL
  # prep grid dataframe
  grid_id_column <- grid_sf %>% select(!!grid_id)
  
  # full grid joined with proportion intersect grid
  output_df <- grid_id_column %>% 
    # join grid ids to grids with proportion values
    left_join(prop_int_df, by = as.character(grid_id[2])) %>% 
    mutate(poly = as.factor(paste0("poly", !!poly_id))) %>%
    # it may be important to remove the poly_id so spread just has the 
    # grid id, new poly id, and the proportions to work with
    select(-!!poly_id) %>% 
    # remove duplicates
    filter(!duplicated(.)) %>% 
    # spread
    spread(poly, proportion) %>% 
    # mutate missing to 0 at each poly var
    mutate_at(vars(contains("poly")), funs(ifelse(is.na(.), 0,
             ifelse(.>1, 1, .)))) %>% 
    # remove idNA
    select(-polyNA) 
  
    # output dataframe
    return(output_df)
}  
```

I'll need to double check to make sure this process works. Takes about a minute to calculate proportion intersect for each county and WRF cell in state. I will eventually come back and calculate intersections for ZIP codes, but I think it would be best to calculate intersect for each year for ZIP code polygons as they may change.

```{r county and census assignment}
# county ---
# create dataframe of intersects and time computation
start_time <- Sys.time()
# proportion intersect for the entire state
co_county_df <- proportion_intersect(poly = colorado_county, poly_id = FIPS,
                                     grid = wrf_grid, grid_id = WRFGRID_ID)

# calculate run time
stop_time <- Sys.time()
compute_time <- stop_time - start_time
compute_time

# grid to county id function
co_county_id <- grid_to_poly(co_county_df, WRFGRID_ID)

# census ---
start_time <- Sys.time()
# proportion intersect for entire state with census and grid
co_census_df <- proportion_intersect(poly = colorado_census, poly_id = GEOID,
                                     grid = wrf_grid, grid_id = WRFGRID_ID)

# calculate run time
stop_time <- Sys.time()
compute_time <- stop_time - start_time
compute_time

# grid to census id function
co_census_id <- grid_to_poly(co_census_df, WRFGRID_ID)

# join census and county ids together
colorado_poly_ids <- co_county_df %>% 
  rename(fips_prop = proportion) %>% 
  full_join(co_census_id, by = "WRFGRID_ID") %>% 
  rename(geoid_prop = proportion)

# print out first 6 lines of polygon IDs to assign to WRFGRID 
head(colorado_poly_ids)

# write this file; will add zipcode later
write_path <- "./data/smoke/colorado_poly_ids.csv"
write_csv(colorado_poly_ids, write_path)
```

Using my proportion intersect to matrix function to create the WRFGRID by polygon matrices that will be used to population-weight pollutant estimates.

```{r proportion intersect matrices}
# county
county_pi_matrix <- pi_matrix(grid_sf = wrf_grid, grid_id = WRFGRID_ID, 
                              prop_int_df = co_county_df, poly_id = FIPS)
# check dimensions of county matrix 
# should be 29580 wrfgrids by 64 counties plus grid id column
# i think something in the function is duplicating
dim(county_pi_matrix)

# census
census_pi_matrix <- pi_matrix(grid_sf = wrf_grid, grid_id = WRFGRID_ID, 
                              prop_int_df = co_census_df, poly_id = GEOID)
# dims of census matrix (should be 29580 wrfids by 1249 census geoids)
dim(census_pi_matrix)

# write census and county matrices ----
# write county
write_county <- "./data/smoke/colorado_county_wrf_int_prop.csv"
write_csv(county_pi_matrix, write_county)

# write census
write_census <- "./data/smoke/colorado_census_wrf_int_prop.csv"
write_csv(census_pi_matrix, write_census)
```

## To Do:

1. Check a small subset of intersects (maybe one county) to make sure values in big matrix match.
2. Add in zipcode calculations to be used in Colorado wildfire project.
